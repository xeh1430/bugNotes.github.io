<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="路漫漫其修远兮！"><title>数据结构与算法(七)——散列表（哈希表） | xeh的学习笔记</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">数据结构与算法(七)——散列表（哈希表）</h1><a id="logo" href="/.">xeh的学习笔记</a><p class="description">将记录当成一种习惯</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">数据结构与算法(七)——散列表（哈希表）</h1><div class="post-meta">Apr 29, 2019<span> | </span><span class="category"><a href="/categories/数据结构/">数据结构</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 1.7k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 5</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#散列表介绍"><span class="toc-number">1.</span> <span class="toc-text">散列表介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#装载因子（load-factor）"><span class="toc-number">1.1.</span> <span class="toc-text">装载因子（load factor）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#散列函数"><span class="toc-number">2.</span> <span class="toc-text">散列函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#设计要求"><span class="toc-number">2.1.</span> <span class="toc-text">设计要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#好的散列函数"><span class="toc-number">2.2.</span> <span class="toc-text">好的散列函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设计方法"><span class="toc-number">2.3.</span> <span class="toc-text">设计方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#散列冲突"><span class="toc-number">3.</span> <span class="toc-text">散列冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#开放寻址法"><span class="toc-number">3.1.</span> <span class="toc-text">开放寻址法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链表法"><span class="toc-number">3.2.</span> <span class="toc-text">链表法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工业级的散列表"><span class="toc-number">4.</span> <span class="toc-text">工业级的散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特性"><span class="toc-number">4.1.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设计思路"><span class="toc-number">4.2.</span> <span class="toc-text">设计思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用"><span class="toc-number">5.</span> <span class="toc-text">应用</span></a></li></ol></div></div><div class="post-content"><h3 id="散列表介绍"><a href="#散列表介绍" class="headerlink" title="散列表介绍"></a>散列表介绍</h3><p><strong>散列表（Hash Table，也叫哈希表）：</strong>是根据关键码值(Key value)而直接进行访问的数据结构。</p>
<p>通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<strong>散列函数</strong>，存放记录的数组叫做<strong>散列表</strong>。</p>
<p>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</p>
<p><strong>散列表的插入、查找和删除跟数组类似，根据散列冲突的解决方式有所不同</strong></p>
<h4 id="装载因子（load-factor）"><a href="#装载因子（load-factor）" class="headerlink" title="装载因子（load factor）"></a>装载因子（load factor）</h4><p>表示散列表中空位的多少。<br><code>散列表的装载因子 = 填入表中的元素个数 / 散列表的长度</code><br>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p>
<p><strong>当散列表的装载因子超过某个阈值时，就需要进行扩容；在装载因子小于某个值之后，启动动态缩容。</strong></p>
<p><img src="https://xeh1430.github.io/img/hashTable.png" alt> </p>
<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>散列函数就是将 key 转换成散列表下标的函数。</p>
<h4 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h4><ol>
<li>散列函数计算得到的散列值是一个非负整数；</li>
<li>如果 key1 = key2，那 hash(key1) == hash(key2)； </li>
<li>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。</li>
</ol>
<h4 id="好的散列函数"><a href="#好的散列函数" class="headerlink" title="好的散列函数"></a>好的散列函数</h4><ol>
<li>散列函数的设计不能太复杂</li>
<li>散列函数生成的值要尽可能随机并且均匀分布</li>
</ol>
<h4 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h4><p>数据分析法、直接寻址法、平方取中法、折叠法、随机数法</p>
<h3 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h3><p>两个不同的 key 通过散列函数得到相同的 hashCode(散列值)，即为散列冲突。</p>
<p>散列冲突的解决方法：<strong>开放寻址法（open addressing）和链表法（chaining）</strong><br><strong>当数据量比较小、装载因子小的时候，适合采用开放寻址法；存储大对象、大数据量的散列表适合使用链表法。</strong></p>
<h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p>开放寻址法：出现了散列冲突，我们就重新探测一个空闲位置，将其插入。</p>
<p><strong>优点：</strong>散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度；序列化简单。<br><strong>缺点：</strong>删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据；装载因子的上限不能太大，比链表法更浪费内存空间。</p>
<p><strong>线性探测（Linear Probing）</strong><br>插入：当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p>
<p>查找：我们通过散列函数求出要查找元素的键值对应的 散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的 元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元 素并没有在散列表中。</p>
<p>删除：<strong>删除比较特殊</strong>，直接删除数据会导致原来的查找算法失效，所以要将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空 间，并不是停下来，而是继续往下探测。</p>
<p>缺点：散列表插入数值越多，散列冲突发生概率越高，需要探测的时间越久。插入、查找和删除的时间复杂度趋向于 O(n)。</p>
<p><strong>二次探测（Quadratic probing）</strong><br>二次探测与线性探测类似，线性探测每次探测的步长是 1，而二次探测探测的步长就变成了原来的“二次方”。</p>
<p><strong>双重散列（Double hashing）</strong><br>使用多组散列函数计算 hashCode，我们先用第一个散列函数，如果计算得到的存储位置已经被 占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p>
<p><strong>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽 可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。</strong></p>
<h4 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h4><p>将所有哈希地址相同的都链接在同一个链表中 ，因而查找、插入和删除主要在同义词链中进行。<br>链地址法适用于经常进行插入和删除的情况。 </p>
<p><strong>优点：</strong>内存的利用率比开放寻址法要高，对大装载因子的容忍度更高；比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。<br><strong>缺点：</strong>比较小的对象的存储，内存消耗大；存储大对象内存消耗忽略不计。</p>
<p><img src="https://xeh1430.github.io/img/hashLinked.png" alt> </p>
<p>插入：只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，时间复杂度是 O(1)。</p>
<p>查找、删除：通过散列函数计算出对应的槽， 然后遍历链表查找或者删除。这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。</p>
<h3 id="工业级的散列表"><a href="#工业级的散列表" class="headerlink" title="工业级的散列表"></a>工业级的散列表</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol>
<li>持快速的查询、插入、删除操作；</li>
<li>内存占用合理，不能浪费过多的内存空间；</li>
<li>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。</li>
</ol>
<h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><ol>
<li>设计一个合适的散列函数；</li>
<li>定义装载因子阈值，并且设计动态扩容策略；</li>
<li>选择合适的散列冲突解决方法。</li>
</ol>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><strong>Word 文档中单词拼写检查功能</strong><br>用散列表来存储整个英文单词词典（常用的英文单词有 20 万个左右，1 个字符占用 1 个字节，最多占用 20MB）。<br>当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正 确；如果没有查到，则说明拼写可能有误，给予提示。</p>
<p><strong>java 中的HashMap</strong><br>HashMap 底层采用链表法来解决冲突。<br>在 JDK1.8 版本中，为了对 HashMap 做进一步优化，我们引入了红黑树。而当链表长度太 长（默认超过 8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/text/dataStructure8.html">数据结构与算法(八)——二叉树（）</a><a class="next" href="/text/dataStructure6.html">数据结构与算法(六)——跳表</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'beb8cdcc473672dd54e5',
  clientSecret: '6fb75946c9614f3b21462fb9115bdcc7c9e08072',
  repo: 'xeh1430.github.io',
  owner: 'xeh1430',
  admin: ['xeh1430'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Web-Service/">Web Service</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring-boot/">spring boot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读/">阅读</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/text/dataStructure8.html">数据结构与算法(八)——二叉树（）</a></li><li class="post-list-item"><a class="post-list-link" href="/text/dataStructure7.html">数据结构与算法(七)——散列表（哈希表）</a></li><li class="post-list-item"><a class="post-list-link" href="/text/dataStructure6.html">数据结构与算法(六)——跳表</a></li><li class="post-list-item"><a class="post-list-link" href="/text/dataStructure5.html">数据结构与算法(五)——递归</a></li><li class="post-list-item"><a class="post-list-link" href="/text/dataStructure4.html">数据结构与算法(四)——队列</a></li><li class="post-list-item"><a class="post-list-link" href="/text/dataStructure3.html">数据结构与算法(三)——栈</a></li><li class="post-list-item"><a class="post-list-link" href="/text/feeling.html">“耐性”不要太好</a></li><li class="post-list-item"><a class="post-list-link" href="/text/firstAid.html">生活急救常识</a></li><li class="post-list-item"><a class="post-list-link" href="/text/dataStructure2.html">数据结构与算法(二)——数组、链表</a></li><li class="post-list-item"><a class="post-list-link" href="/text/dataStructure1.html">数据结构与算法(一)——复杂度分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://news.cnblogs.com/" title="博客园新闻" target="_blank">博客园新闻</a><ul></ul><a href="http://www.ruanyifeng.com/blog/" title="阮一峰的网络日志" target="_blank">阮一峰的网络日志</a><ul></ul><a href="https://gitee.com/explore" title="码云 开源软件" target="_blank">码云 开源软件</a><ul></ul><a href="https://github.com/" title="github" target="_blank">github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">xeh的学习笔记.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
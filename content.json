{"meta":{"title":"xeh的学习笔记","subtitle":"将记录当成一种习惯","description":"路漫漫其修远兮！","author":"xeh","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"海南记闻","slug":"20190917-海南记闻","date":"2019-09-17T07:30:07.000Z","updated":"2019-09-17T09:47:21.045Z","comments":true,"path":"text/hainan.html","link":"","permalink":"http://yoursite.com/text/hainan.html","excerpt":"前段时间，因为工作原因，在海南海口呆了三个多星期，第一次踏入海南岛，所以想将在海南的所见所闻记录下来。 从广州飞往海南，由于搭的是晚班机，到海南已是深夜，即使是深夜，还是能感受到海岛的热带气息。搭乘的士前往酒店，看着夜色中道路两旁的椰子树，憧憬着接下来的海南生活。 第二天早上八点，走出酒店，万里无云，大大的太阳高挂在天空，阳光刺得张不开眼睛，暴露在阳光下的皮肤火辣辣的感觉，紫外线强度是真的高，难怪跟家人朋友说起去海南，第一反应就是黑了没。阳光虽然刺眼，但每天的温度都在 25~33 之间，加上微风，只要不是直接暴露在太阳下，也不是很热，比广州真的凉爽多了。都说去海南旅游，从海口的环境和空气质量就知道，确实适合旅游，放松身心。","text":"前段时间，因为工作原因，在海南海口呆了三个多星期，第一次踏入海南岛，所以想将在海南的所见所闻记录下来。 从广州飞往海南，由于搭的是晚班机，到海南已是深夜，即使是深夜，还是能感受到海岛的热带气息。搭乘的士前往酒店，看着夜色中道路两旁的椰子树，憧憬着接下来的海南生活。 第二天早上八点，走出酒店，万里无云，大大的太阳高挂在天空，阳光刺得张不开眼睛，暴露在阳光下的皮肤火辣辣的感觉，紫外线强度是真的高，难怪跟家人朋友说起去海南，第一反应就是黑了没。阳光虽然刺眼，但每天的温度都在 25~33 之间，加上微风，只要不是直接暴露在太阳下，也不是很热，比广州真的凉爽多了。都说去海南旅游，从海口的环境和空气质量就知道，确实适合旅游，放松身心。海口有个广州看不到的景象，每天都可以看到一大批人骑着电驴上下班，基本上每辆车都上牌，这点感觉很好。当然，在早高峰晚高峰某个繁忙的路口，你有时可以看到一群因为没有戴头盔而在路旁跟交警叔叔一起指挥路况的人。 生活方面，相对于广州，海口给我的感觉是，生活节奏比较慢，物价一点也不低，景点、好玩的地方比较少，吃的地方也很比较少（就我出差的海口名门广场附近而言），有次晚上9点多去酒店旁边的广场准备吃晚饭，结果没找到吃的，差不多都打烊了。一方面是生活节奏的原因，另一方面人口的原因也很大，我查了下整个海南的人口 934万（截至2018年），广州人口 1490.44万（截至2018年），而海南的陆地面积是广州的 4.76 倍。习惯了广州的节奏，突然间跑到海口确实有点让人不适应。 趁着几趟打车的途中，跟司机交谈后，也了解到一些关于海南或是海口的东西。众所周知，海南省是中国第二大岛，一般来往海南只能飞机和船，入海南岛的火车、汽车、公交都是靠船只载过琼州海峡的。海南有高速，但是没有高速收费站，高速的费用包含在油费中，所以在海南加油会比较贵。海口路旁的行道树都是椰子，司机说这些都归海口园林局管，椰子卖了的钱用于整个市的绿化工作，不用上交，上面也不拨款，自给自足（司机说法，不确定真伪）。 话说，来海南之前以为海南人民应该都很黑吧，来了发现也不黑，很多都比我白，当然我介于不黑不白的正常肤色，可能是现在大家防晒工作处理得好，也可能是我接触的都是上班族吧。回到公司说起这事，发现一个海南的同事真白，当然之前不知道他是海南的，按他的话讲就是宅，晒得少。 还有一点就是，出差是个减肥的好办法！","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[],"keywords":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}]},{"title":"数据结构与算法(十五)——桶、计数、基数排序","slug":"20190807-数据结构-桶计数基数排序","date":"2019-08-07T07:30:07.000Z","updated":"2019-08-07T09:47:09.591Z","comments":true,"path":"text/dataStructure15.html","link":"","permalink":"http://yoursite.com/text/dataStructure15.html","excerpt":"桶排序、计数排序、基数排序都是线性排序，都是非基于比较的排序算法，都不涉及元素之间的比较操作。","text":"桶排序、计数排序、基数排序都是线性排序，都是非基于比较的排序算法，都不涉及元素之间的比较操作。 桶排序（Bucket sort）将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶内排完序之后，再把每个桶里的数据按照顺序依次 取出，组成的序列就是有序的了。 时间复杂度为 O(n) 12345678910111213141516171819202122232425262728293031public static void basket(int data[])//data为待排序数组&#123; int n=data.length; int bask[][]=new int[10][n]; int index[]=new int[10]; int max=Integer.MIN_VALUE; for(int i=0;i&lt;n;i++)&#123; max=max&gt;(Integer.toString(data[i]).length())?max:(Integer.toString(data[i]).length()); &#125; String str; for(int i=max-1;i&gt;=0;i--)&#123; for(int j=0;j&lt;n;j++)&#123; str=\"\"; if(Integer.toString(data[j]).length()&lt;max)&#123; for(int k=0;k&lt;max-Integer.toString(data[j]).length();k++) str+=\"0\"; &#125; str+=Integer.toString(data[j]); bask[str.charAt(i)-'0'][index[str.charAt(i)-'0']++]=data[j]; &#125; int pos=0; for(int j=0;j&lt;10;j++)&#123; for(int k=0;k&lt;index[j];k++)&#123; data[pos++]=bask[j][k]; &#125; &#125; for(intx=0;x&lt;10;x++)index[x]=0; &#125;&#125; 计数排序（Counting sort）计数排序对输入的数据有附加的限制条件： 输入的线性表的元素属于有限偏序集S； 设输入的线性表的长度为n，|S|=k（表示集合S中元素的总数目为k），则k=O(n)。 计数排序的时间复杂性为O(n)。 算法的步骤如下： 找出待排序的数组中最大和最小的元素 统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项 对所有的计数累加 (从 C 中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素 i 放在新数组的第 C[i] 项，每放一个元素就将 C[i] 减去1 12345678910111213141516171819202122232425262728293031323334353637383940// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。 public void countingSort(int[] a, int n) &#123; if (n &lt;= 1) return; // 查找数组中数据的范围 int max = a[0]; for (int i = 1; i &lt; n; ++i) &#123; if (max &lt; a[i]) &#123; max = a[i]; &#125; &#125; int[] c = new int[max + 1]; // 申请一个计数数组 c，下标大小 [0,max] for (int i = 0; i &lt;= max; ++i) &#123; c[i] = 0; &#125; // 计算每个元素的个数，放入 c 中 for (int i = 0; i &lt; n; ++i) &#123; c[a[i]]++; &#125; // 依次累加 for (int i = 1; i &lt;= max; ++i) &#123; c[i] = c[i-1] + c[i]; &#125; // 临时数组 r，存储排序之后的结果 int[] r = new int[n]; // 计算排序的关键步骤，有点难理解 for (int i = n - 1; i &gt;= 0; --i) &#123; int index = c[a[i]]-1; r[index] = a[i]; c[a[i]]--; &#125; // 将结果拷贝给 a 数组 for (int i = 0; i &lt; n; ++i) &#123; a[i] = r[i]; &#125; &#125; 计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很 多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型 的，要将其在不改变相对大小的情况下，转化为非负整数。 基数排序（Radix sort）将整数按位数切割成不同的数字，然后按每个位数分别比较。（由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数） 实现原理将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补0。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。PS:因为根据ASCII 值，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序。 基数排序的方式可以采用LSD（Least significant digital 最低位优先）或MSD（Most significant digital 最高位优先），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class RadixSort&#123; public static void sort(int[] number, int d) //d表示最大的数有多少位 &#123; intk = 0; intn = 1; intm = 1; //控制键值排序依据在哪一位 int[][]temp = newint[10][number.length]; //数组的第一维表示可能的余数0-9 int[]order = newint[10]; //数组orderp[i]用来表示该位是i的数的个数 while(m &lt;= d) &#123; for(inti = 0; i &lt; number.length; i++) &#123; intlsd = ((number[i] / n) % 10); temp[lsd][order[lsd]] = number[i]; order[lsd]++; &#125; for(inti = 0; i &lt; 10; i++) &#123; if(order[i] != 0) for(intj = 0; j &lt; order[i]; j++) &#123; number[k] = temp[i][j]; k++; &#125; order[i] = 0; &#125; n *= 10; k = 0; m++; &#125; &#125; public static void main(String[] args) &#123; int[]data = &#123;73, 22, 93, 43, 55, 14, 28, 65, 39, 81, 33, 100&#125;; RadixSort.sort(data, 3); for(inti = 0; i &lt; data.length; i++) &#123; System.out.print(data[i] + \"\"); &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构与算法(十四)——快排、归并排序","slug":"20190723-数据结构-快速归并排序","date":"2019-07-23T07:30:07.000Z","updated":"2019-08-07T10:01:29.169Z","comments":true,"path":"text/dataStructure14.html","link":"","permalink":"http://yoursite.com/text/dataStructure14.html","excerpt":"快排、归并排序都使用到了分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题 来解决。小的子问题解决了，大问题也就解决了。分治思想跟递归思想很像，一般用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧。","text":"快排、归并排序都使用到了分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题 来解决。小的子问题解决了，大问题也就解决了。分治思想跟递归思想很像，一般用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧。 快排排序（Quick Sort）快排排序算法的操作如下： 挑选基准值：从数列中挑出一个元素，称为“基准”（pivot）; 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成; 递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。 12345678910111213141516171819202122232425262728293031323334public class Application &#123; public static void qSort(int[] arr, int head, int tail) &#123; if (head &gt;= tail || arr == null || arr.length &lt;= 1) &#123; return; &#125; int i = head, j = tail, pivot = arr[(head + tail) / 2]; while (i &lt;= j) &#123; while (arr[i] &lt; pivot) &#123; ++i; &#125; while (arr[j] &gt; pivot) &#123; --j; &#125; if (i &lt; j) &#123; int t = arr[i]; arr[i] = arr[j]; arr[j] = t; ++i; --j; &#125; else if (i == j) &#123; ++i; &#125; &#125; qSort(arr, head, j); qSort(arr, i, tail); &#125; public static void main(String[] args) &#123; int[] arr = new int[]&#123;1, 4, 8, 2, 55, 3, 4, 8, 6, 4, 0, 11, 34, 90, 23, 54, 77, 9, 2, 9, 4, 10&#125;; qSort(arr, 0, arr.length - 1); System.out.println(Arrays.toString(arr)); &#125;&#125; 优化 三数取中法我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。 随机法随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。 归并排序（Merge Sort）归并排序算法(递归法)的操作如下： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针到达序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 12345678910111213141516171819202122232425// 归并排序算法 static void merge_sort_recursive(int[] arr, int[] result, int start, int end) &#123; if (start &gt;= end) return; int len = end - start, mid = (len &gt;&gt; 1) + start; int start1 = start, end1 = mid; int start2 = mid + 1, end2 = end; merge_sort_recursive(arr, result, start1, end1); //左边排序 merge_sort_recursive(arr, result, start2, end2); //右边排序 int k = start; while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) result[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++]; while (start1 &lt;= end1) result[k++] = arr[start1++]; while (start2 &lt;= end2) result[k++] = arr[start2++]; for (k = start; k &lt;= end; k++) arr[k] = result[k];&#125;public static void merge_sort(int[] arr) &#123; int len = arr.length; int[] result = new int[len]; merge_sort_recursive(arr, result, 0, len - 1);&#125; 总结 原地排序 稳定的排序算法 最好 最坏 平均 快速排序 是 不是 $$O(nlogn) O(n^2) O(nlogn)$$ 归并排序 不是 是 $$O(nlogn) O(nlogn) O(nlogn)$$","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构与算法(十三)——冒泡、插入、选择排序","slug":"20190722-数据结构-冒泡插入选择排序","date":"2019-07-22T07:30:07.000Z","updated":"2019-07-22T11:54:46.587Z","comments":true,"path":"text/dataStructure13.html","link":"","permalink":"http://yoursite.com/text/dataStructure13.html","excerpt":"","text":"冒泡排序（Bubble Sort）冒泡排序算法的操作如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 123456789101112131415161718// 冒泡排序，a 表示数组，n 表示数组大小 public void bubbleSort(int[] a, int n) &#123; if (n &lt;= 1) return; for (int i = 0; i &lt; n; ++i) &#123; // 提前退出冒泡循环的标志位 boolean flag = false; for (int j = 0; j &lt; n - i - 1; ++j) &#123; if (a[j] &gt; a[j+1]) &#123; // 交换 int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = true; // 表示有数据交换 &#125; &#125; if (!flag) break; // 没有数据交换，提前退出 &#125; &#125; 插入排序（Insertion Sort）插入排序算法的操作如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤 2-5。 1234567891011121314151617// 插入排序，a 表示数组，n 表示数组大小 public void insertionSort(int[] a, int n) &#123; if (n &lt;= 1) return; for (int i = 1; i &lt; n; ++i) &#123; int value = a[i]; int j = i - 1; // 查找插入的位置 for (; j &gt;= 0; --j) &#123; if (a[j] &gt; value) &#123; a[j+1] = a[j]; // 数据移动 &#125; else &#123; break; &#125; &#125; a[j+1] = value; // 插入数据 &#125; &#125; 选择排序（Selection Sort）选择排序算法的操作如下： 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置； 再从剩余未排序元素中继续寻找最小（大）元素； 放到已排序序列的末尾； 以此类推，直到所有元素均排序完毕。 12345678910111213141516//a 表示数组，n 表示数组大小 public void selectionSort(int[] a, int n) &#123; if (n &lt;= 1) return; int temp = 0; for (int j = 0; j &lt;n - 1;j++) &#123; for (int i = j; i &lt; n - 1; i++) &#123; if (a[j] &gt; a[i + 1]) &#123; // 交换 temp = a[j]; a[j] = a[i + 1]; a[i + 1] = temp; &#125; &#125; &#125;&#125; 总结原地排序算法，空间复杂度为 O(1)。稳定的排序算法，相同元素的前后顺序不变。 原地排序 稳定的排序算法 最好 最坏 平均 冒泡排序 是 是 $$O(n) O(n^2) O(n^2)$$ 插入排序 是 是 $$O(n) O(n^2) O(n^2)$$ 选择排序 是 否 $$O(n^2) O(n^2) O(n^2)$$","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构与算法(十二)——排序算法","slug":"20190719-数据结构-排序算法","date":"2019-07-19T06:30:07.000Z","updated":"2019-08-08T03:01:51.618Z","comments":true,"path":"text/dataStructure12.html","link":"","permalink":"http://yoursite.com/text/dataStructure12.html","excerpt":"","text":"排序算法有很多，最经典的、最常用的冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。 根据时间复杂度可以把常用的排序算法区分为三类 排序算法 时间复杂度 是否基于比较 冒泡、插入、选择 $$O(n^2)$$ 是 快排、归并 $$O(nlogn)$$ 是 桶、计数、基数 $$O(n)$$ 否 如何分析一个“排序算法”？排序算法的执行效率排序算法执行效率的分析，我们一般会从这几个方面来衡量： 1. 最好情况、最坏情况、平均情况时间复杂度为什么要区分这三种时间复杂度呢？第一，区分排序算法，容易对比。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。 2. 时间复杂度的系数、常数 、低阶时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，n 规模很大时，会忽略系数、常数、低阶。 在对同一阶时间复杂度的排序算法性能对比的时候，需要把系数、常数、低阶也考虑进来。 3. 比较次数和交换（或移动）次数基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。 所以，我们在分析排序算法执行效率的时候，要把比较次数和交换（或移动）次数也考虑进去。 排序算法的内存消耗算法的内存消耗可以通过空间复杂度来衡量。 原地排序算法（Sorted in place），是特指空间复杂度是 O(1) 的排序算法。 排序算法的稳定性在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，则称为稳定的排序算法，反之，则为不稳定的排序算法。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构与算法(十一)——图（Graph）","slug":"20190711-数据结构-图","date":"2019-07-11T06:30:07.000Z","updated":"2019-07-11T09:05:02.409Z","comments":true,"path":"text/dataStructure11.html","link":"","permalink":"http://yoursite.com/text/dataStructure11.html","excerpt":"","text":"图的定义图（Graph）是一种复杂的非线性表结构。 顶点（vertex）：图中的元素； 边（edge）：图中的顶点与其他任意顶点建立连接的关系； 顶点的度（degree)：跟顶点相连接的边的条数。 入度（In-degree）和出度（Out-degree）：对于有向图，一个顶点的入度是指以其为终点的边数；出度指以该顶点为起点的边数； 图有多种类型，包括有向图、无向图、简单图、多重图、有向图、无向图等； 图的分类 有向图和无向图图的每条边规定一个方向，那么得到的图称为有向图；相反，边没有方向的图称为无向图。 简单图 任意两顶点之间只有一条边（在有向图中为两顶点之间每个方向只有一条边）； 每条边所关联的是两个不同的顶点 带权图（weighted graph）在带权图中，每条边都有一个权重（weight）[非负实数]。 多重图图中某两个顶点之间的边数多于一条，又允许顶点通过同一条边和自己关联，则称为多重图 图的存储邻接矩阵（Adjacency Matrix）邻接矩阵是图的常用存储表示，它的底层依赖一个二维数组。它用两个数组分别存储数据元素（顶点）的信息和数据元素之间的关系（边或弧）的信息。 优点： 邻接矩阵的存储方式简单、直接，可以高效的获取两个顶点的关系； 计算方便。（求解最短路径 Floyd-Warshall 算法） 用邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。 对于无向图，a[i][j] == a[j][i]，我们只需要存储一个就好，在二维数组中，通过对角线可以划分为两部分，我们只要利用其中一部分的空间就可以了，另外一部分则是多余的。 存储的是稀疏图（Sparse Matrix）：顶点很多，但每个顶点的边并不多，邻接矩阵的存储方法就更加浪费空间了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class AMWGraph &#123; private ArrayList vertexList;//存储点的链表 private int[][] edges;//邻接矩阵，用来存储边 private int numOfEdges;//边的数目 public AMWGraph(int n) &#123; //初始化矩阵，一维数组，和边的数目 edges=new int[n][n]; vertexList=new ArrayList(n); numOfEdges=0; &#125; //得到结点的个数 public int getNumOfVertex() &#123; return vertexList.size(); &#125; //得到边的数目 public int getNumOfEdges() &#123; return numOfEdges; &#125; //返回结点i的数据 public Object getValueByIndex(int i) &#123; return vertexList.get(i); &#125; //返回v1,v2的权值 public int getWeight(int v1,int v2) &#123; return edges[v1][v2]; &#125; //插入结点 public void insertVertex(Object vertex) &#123; vertexList.add(vertexList.size(),vertex); &#125; //插入结点 public void insertEdge(int v1,int v2,int weight) &#123; edges[v1][v2]=weight; numOfEdges++; &#125; //删除结点 public void deleteEdge(int v1,int v2) &#123; edges[v1][v2]=0; numOfEdges--; &#125; //得到第一个邻接结点的下标 public int getFirstNeighbor(int index) &#123; for(int j=0;j&lt;vertexList.size();j++) &#123; if (edges[index][j]&gt;0) &#123; return j; &#125; &#125; return -1; &#125; //根据前一个邻接结点的下标来取得下一个邻接结点 public int getNextNeighbor(int v1,int v2) &#123; for (int j=v2+1;j&lt;vertexList.size();j++) &#123; if (edges[v1][j]&gt;0) &#123; return j; &#125; &#125; return -1; &#125;&#125; 邻接表（Adjacency List）邻接表与散列表有点类似，点击了解散列表 图的顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。 邻接表存储起来比较节省空间，但是使用起来就比较耗时间。 当链表过长，为了提高查找效率，我们可以将链表换成其他更加高效的数据结构，如平衡二叉树（红黑树）、跳表、散列表等1234567891011121314151617public class Graph &#123; // 无向图 private int v; // 顶点的个数 private LinkedList&lt;Integer&gt; adj[]; // 邻接表 public Graph(int v) &#123; this.v = v; adj = new LinkedList[v]; for (int i=0; i&lt;v; ++i) &#123; adj[i] = new LinkedList&lt;&gt;(); &#125; &#125; public void addEdge(int s, int t) &#123; // 无向图一条边存两次 adj[s].add(t); adj[t].add(s); &#125;&#125; 图的遍历深度优先搜索算法（DFS）深度优先搜索（Depth-First-Search），类似于树的先序遍历，从图中某个顶点v出发，访问该顶点，然后依次从v的未被访问的邻接点出发继续深度优先遍历图中的其余顶点，直至图中所有与v有路径相通的顶点都被访问完为止。 深度优先搜索的时间复杂度为 O(E)，E 表示边的个数；空间复杂度为 O(V)，V 表示顶点的个数。 12345678910111213141516171819202122232425262728293031//找到顶点后，终止递归的标志boolean found = false; // 全局变量或者类成员变量 public void dfs(int s, int t) &#123; found = false; //visited 记录已经被访问的顶点，避免顶点被重复访问 boolean[] visited = new boolean[v]; //prev 记录搜索路径 int[] prev = new int[v]; for (int i = 0; i &lt; v; ++i) &#123; prev[i] = -1; &#125; recurDfs(s, t, visited, prev); print(prev, s, t);&#125; private void recurDfs(int w, int t, boolean[] visited, int[] prev) &#123; if (found == true) return; visited[w] = true; if (w == t) &#123; found = true; return; &#125; for (int i = 0; i &lt; adj[w].size(); ++i) &#123; int q = adj[w].get(i); if (!visited[q]) &#123; prev[q] = w; recurDfs(q, t, visited, prev); &#125; &#125;&#125; 广度优先搜索算法（BFS）广度优先搜索（Breadth-First-Search），一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。 广度优先搜索的时间复杂度为 O(E)，，E 表示边的个数；空间复杂度为 O(V)，V 表示顶点的个数。 123456789101112131415161718192021222324252627282930313233343536public void bfs(int s, int t) &#123; if (s == t) return; //visited 记录已经被访问的顶点，避免顶点被重复访问 boolean[] visited = new boolean[v]; visited[s]=true; //queue 用来存储已经被访问、但相连的顶点还没有被访问的顶点 Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(s); //prev 记录搜索路径 int[] prev = new int[v]; for (int i = 0; i &lt; v; ++i) &#123; prev[i] = -1; &#125; while (queue.size() != 0) &#123; int w = queue.poll(); for (int i = 0; i &lt; adj[w].size(); ++i) &#123; int q = adj[w].get(i); if (!visited[q]) &#123; prev[q] = w; if (q == t) &#123; print(prev, s, t); return; &#125; visited[q] = true; queue.add(q); &#125; &#125; &#125;&#125; private void print(int[] prev, int s, int t) &#123; // 递归打印 1-&gt;9 的路径 if (prev[t] != -1 &amp;&amp; t != s) &#123; print(prev, s, prev[t]); &#125; System.out.print(t + \" \");&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构与算法(十)——堆（Heap）","slug":"20190627-数据结构-堆","date":"2019-06-27T02:30:07.000Z","updated":"2019-06-27T14:04:32.530Z","comments":true,"path":"text/dataStructure10.html","link":"","permalink":"http://yoursite.com/text/dataStructure10.html","excerpt":"","text":"定义堆（Heap）是一种特殊的树。 堆是一个完全二叉树； 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 最大堆（max heap）：每个节点的值都大于等于子树中每个节点值的堆。最小堆（min heap）：每个节点的值都小于等于子树中每个节点值的堆。 操作完全二叉树比较适合用数组来存储，数组存储非常节省存储空间。因为不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。 一个包含 n 个节点的完全二叉树，树的高度不会超过 log2n。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 O(logn)。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn) 插入往堆中插入一个元素，我们需要进行调整，让其重新满足堆的特性，这个过程叫作堆化（heapify）。 堆化，就是顺着节点所在的路径，向上或者向下，对比，然后交换。12345678910111213141516171819202122public class Heap &#123; private int[] a; // 数组，从下标 1 开始存储数据 private int n; // 堆可以存储的最大数据个数 private int count; // 堆中已经存储的数据个数 public Heap(int capacity) &#123; a = new int[capacity + 1]; n = capacity; count = 0; &#125; public void insert(int data) &#123; if (count &gt;= n) return; // 堆满了 ++count; a[count] = data; int i = count; while (i/2 &gt; 0 &amp;&amp; a[i] &gt; a[i/2]) &#123; // 自下往上堆化 swap(a, i, i/2); // swap() 函数作用：交换下标为 i 和 i/2 的两个元素 i = i/2; &#125; &#125;&#125; 删除最大堆，当我们删除堆顶元素之后，就需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后我们再迭代地删除第二大节点，以此类推，直到叶子节点被删除。 最小堆，操作类似，只是元素变为第二小的元素，然后依次迭代。 简化实现，删除元素后，将最后一个节点放到删除位置，然后利用同样的父子节点对比方法，进行堆化。1234567891011121314151617public void removeMax() &#123; if (count == 0) return -1; // 堆中没有数据 a[1] = a[count]; --count; heapify(a, count, 1);&#125; private void heapify(int[] a, int n, int i) &#123; // 自上往下堆化 while (true) &#123; int maxPos = i; if (i*2 &lt;= n &amp;&amp; a[i] &lt; a[i*2]) maxPos = i*2; if (i*2+1 &lt;= n &amp;&amp; a[maxPos] &lt; a[i*2+1]) maxPos = i*2+1; if (maxPos == i) break; swap(a, i, maxPos); i = maxPos; &#125;&#125; 应用堆排序","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构与算法(九)——红黑树（Red Black Tree）","slug":"20190606-数据结构-红黑树","date":"2019-06-06T02:30:07.000Z","updated":"2019-06-19T08:12:30.993Z","comments":true,"path":"text/dataStructure9.html","link":"","permalink":"http://yoursite.com/text/dataStructure9.html","excerpt":"","text":"性质 红黑树是一种自平衡二叉查找树（BST） 节点非黑即红，根节点是黑色的; 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据； 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的； 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点； 自平衡二叉树AVL树（经典平衡树, 所有操作的最坏复杂度都是 O(log n)）、Treap、伸展树、红黑树、替罪羊树、AA树、加权平衡树等红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。 操作插入红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。 红黑树插入调整的基础操作：左右旋转和改变颜色。 情况1：插入节点位于树的根上，没有父节点。直接改变它的颜色，把它变成黑色就可以了。 情况2：插入节点的父节点是黑色的，直接插入就行了。 情况3：如图 N 为红，P 为红，（祖节点一定存在，且为黑，下边同理）U 也为红，这里不论 P 是 G 的左孩子，还是右孩子；不论 N 是 P 的左孩子，还是右孩子。 操作：把 P、U 改为黑色，G 改为红色，如 G 为根节点进行情况1操作，否则进行情况4和情况5 解析：N、P 都为红，违反性质4；若把 P 改为黑，符合性质4，显然右边少了一个黑节点，违反性质5；所以我们把G，U都改为相反色，符合性质5，违反性质2；将 G 作为关注点，进行下一步操作。 情况4：N 为红，P 为红，U 为黑，P 为 G 的左孩子，N 为 P 的右孩子（或者 P 为 G 的右孩子，N 为 P 的左孩子；反正两方向相反）。 操作：需要进行两次变换（旋转），图中只显示了一次变换—–首先 P、N 变换，颜色不变；然后就变成了情况5的情况，按照情况4操作，即结束。 情况5：N 为红，P 为红，U 为黑，P 为 G 的左孩子，N 为 P 的左孩子（或者 P 为 G 的右孩子，N 为 P 的左孩子；反正就是同向的）。 操作：P、G 变色，P、G 变换即左左单旋（或者右右单旋），结束。 删除如果需要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题，下面只讨论删除只有一个子节点的问题情况2-6图中，N 都是是删除了黑色节点后替换上来的子节点 情况1：要删除 N ，N 为根节点，直接删除，新的根节点为黑色。 情况2：S 为红色（那么父节点 P 一定是黑，子节点一定是黑），N 是 P 的左孩子（或者 N 是 P 的右孩子）。 操作：以 P 为中心左旋，S 变为祖节点，P、S 颜色对调，违法性质5，未结束，接下来按情况4、情况5或情况6来处理。 情况3：P、S 及 S 的孩子们都为黑。 操作：S 改为红色，接着按情况2做处理。 情况4：P 为红（S 一定为黑），S 的孩子们都为黑。 操作：P变为黑，S改为红，结束。 情况5：P 任意色，S 为黑，N 是 P 的左孩子，S 的右孩子 SR 为红，S 的左孩子任意（或者是 N 是 P 的右孩子，S 的左孩子为红，S 的右孩子任意）。 操作：SR（SL）改为黑，P 改为黑，S 改为 P 的颜色，p 左旋，结束。 情况6：S 为黑，S 的左孩子 SL 为红，S 的右孩子 SR 为黑（或者 S 的右孩子为红，S 的左孩子为黑）。 操作：SL（或SR）改为黑，S 改为红，SL（SR）、S 右旋（左旋）；此时就回到了情况5，SL（SR）变成了黑 S，S 变成了红。 应用java 中的 treeMap JDK1.8中 HashMap 在单链表冲突后采用红黑树提高查找插入的效率 参考维基百科的红黑树博客园-红黑树","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构与算法(八)——二叉树（Binary Tree）","slug":"20190527-数据结构-二叉树","date":"2019-05-27T06:30:07.000Z","updated":"2019-06-05T07:51:39.219Z","comments":true,"path":"text/dataStructure8.html","link":"","permalink":"http://yoursite.com/text/dataStructure8.html","excerpt":"","text":"树（Tree）介绍树（Tree）：一种非线性表结构。是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。 特点每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树。 高度（Height）、深 度（Depth）、层（Level） 节点的高度 = 节点到叶子节点的最长路径（边数）节点的深度 = 根节点到这个节点所经历的边的个数节点的层数 = 节点的深度+1树的高度 = 根节点的高度 种类无序树、有序树、二叉树、满二叉树、完全二叉树、平衡二叉树（avl）、二叉查找树（二叉搜索树、BST）、霍夫曼树、红黑树、B树 二叉树（Binary Tree）二叉树，每个节点最多有两个子节点，分别是左子节点和右子节点。 存储一棵二叉树，我们有两种方法，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。 二叉树的遍历广度优先（BFS)层次遍历：先访问离根节点最近的节点。 深度优先（DFS)：前序遍历、中序遍历和后序遍历 前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印 它的右子树。中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它 的右子树。后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打 印这个节点本身。 二叉查找树（Binary Search Tree）二叉查找树也叫二叉搜索树（BST），是为了实现快 速查找而生的。不仅支持快速查找一个数据，还支持快速插入、删除一个数据。 二叉查找树要求，在树中的任意一个节点，其左子树中的每 个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。 平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn)。 二叉查找树的查找操作查找一个节点 找根节点，等于就返回； 比根节点小，左子树中递归查找； 比根节点大，右子树中递归查找。123456789101112131415161718192021public class BinarySearchTree &#123; private Node tree; public Node find(int data) &#123; Node p = tree; while (p != null) &#123; if (data &lt; p.data) p = p.left; else if (data &gt; p.data) p = p.right; else return p; &#125; return null; &#125; public static class Node &#123; private int data; private Node left; private Node right; public Node(int data) &#123; this.data = data; &#125; &#125; &#125; 二叉查找树的插入操作 从根节点开始，依次比较要插入的数据和节点的大小关系; 插入的数据比节点数值大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；不为空，就再递归遍历右子树，查找插入位置； 插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；不为空，就再递归遍历左子树，查找插入位置。12345678910111213141516171819202122public void insert(int data) &#123; if (tree == null) &#123; tree = new Node(data); return; &#125; Node p = tree; while (p != null) &#123; if (data &gt; p.data) &#123; if (p.right == null) &#123; p.right = new Node(data); return; &#125; p = p.right; &#125; else &#123; // data &lt; p.data if (p.left == null) &#123; p.left = new Node(data); return; &#125; p = p.left; &#125; &#125; &#125; 二叉查找树的删除操作要删除节点的子节点个数的不同，分三种情况来处理。 要删除的节点没有子节点，只需要直接将父节点中，指向要删除节点的指 针置为 null。 要删除的节点只有一个子节点（只有左子节点或者右子节点），只需要更 新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。 要删除的节点有两个子节点。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上，然后再删除掉这个最小节点。 1234567891011121314151617181920212223242526272829303132public void delete(int data) &#123; Node p = tree; // p 指向要删除的节点，初始化指向根节点 Node pp = null; // pp 记录的是 p 的父节点 while (p != null &amp;&amp; p.data != data) &#123; pp = p; if (data &gt; p.data) p = p.right; else p = p.left; &#125; if (p == null) return; // 没有找到 // 要删除的节点有两个子节点 if (p.left != null &amp;&amp; p.right != null) &#123; // 查找右子树中最小节点 Node minP = p.right; Node minPP = p; // minPP 表示 minP 的父节点 while (minP.left != null) &#123; minPP = minP; minP = minP.left; &#125; p.data = minP.data; // 将 minP 的数据替换到 p 中 p = minP; // 下面就变成了删除 minP 了 pp = minPP; &#125; // 删除节点是叶子节点或者仅有一个子节点 Node child; // p 的子节点 if (p.left != null) child = p.left; else if (p.right != null) child = p.right; else child = null; if (pp == null) tree = child; // 删除的是根节点 else if (pp.left == p) pp.left = child; else pp.right = child;&#125; 散列表很高效，为什么还要用二叉查找树？ 散列表中的数据是无序存储的；二叉查找树有序； 散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定； 尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，加起来就不一定比平衡二叉查找树的效率高； 散列表的构造比二叉查找树要复杂，需要考虑的东西很多； 为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散 列表，不然会浪费一定的存储空间。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构与算法(六)——跳表","slug":"20190429-数据结构-跳表","date":"2019-04-29T06:30:07.000Z","updated":"2019-04-29T08:31:42.000Z","comments":true,"path":"text/dataStructure6.html","link":"","permalink":"http://yoursite.com/text/dataStructure6.html","excerpt":"","text":"跳表介绍跳表（Skip list）：是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。 跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找，可以支持快速的插入、删除、查找操作。 Redis 中的有序集合（Sorted Set）就是用跳表来实现的。 图解跳表从上图可知，跳表就是链表加多级索引的结构。 作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。跳表是通过随机函数来维护这种“平衡性”的。 快速查找的原理在最高级索引上查找最后一个小于当前查找元素的位置，然后再跳到次高级索引继续查找，直到跳到最底层为止，这时候以及十分接近要查找的元素的位置了(如果查找元素存在的话)。由于根据索引可以一次跳过多个元素，所以跳查找的查找速度也就变快了。 跳表的复杂度时间复杂度：O(logn)空间复杂度：O(n) 跳表的代码实现跳表中存储的是正整数，并且存储的是不重复的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117public class SkipList &#123; private static final int MAX_LEVEL = 16; private int levelCount = 1; private Node head = new Node(); // 带头链表 private Random r = new Random(); //查询 public Node find(int value) &#123; Node p = head; for (int i = levelCount - 1; i &gt;= 0; --i) &#123; while (p.forwards[i] != null &amp;&amp; p.forwards[i].data &lt; value) &#123; p = p.forwards[i]; &#125; &#125; if (p.forwards[0] != null &amp;&amp; p.forwards[0].data == value) &#123; return p.forwards[0]; &#125; else &#123; return null; &#125; &#125; //添加 public void insert(int value) &#123; int level = randomLevel(); Node newNode = new Node(); newNode.data = value; newNode.maxLevel = level; Node update[] = new Node[level]; for (int i = 0; i &lt; level; ++i) &#123; update[i] = head; &#125; // record every level largest value which smaller than insert value in update[] Node p = head; for (int i = level - 1; i &gt;= 0; --i) &#123; while (p.forwards[i] != null &amp;&amp; p.forwards[i].data &lt; value) &#123; p = p.forwards[i]; &#125; update[i] = p;// use update save node in search path &#125; // in search path node next node become new node forwords(next) for (int i = 0; i &lt; level; ++i) &#123; newNode.forwards[i] = update[i].forwards[i]; update[i].forwards[i] = newNode; &#125; // update node hight if (levelCount &lt; level) levelCount = level; &#125; //删除 public void delete(int value) &#123; Node[] update = new Node[levelCount]; Node p = head; for (int i = levelCount - 1; i &gt;= 0; --i) &#123; while (p.forwards[i] != null &amp;&amp; p.forwards[i].data &lt; value) &#123; p = p.forwards[i]; &#125; update[i] = p; &#125; if (p.forwards[0] != null &amp;&amp; p.forwards[0].data == value) &#123; for (int i = levelCount - 1; i &gt;= 0; --i) &#123; if (update[i].forwards[i] != null &amp;&amp; update[i].forwards[i].data == value) &#123; update[i].forwards[i] = update[i].forwards[i].forwards[i]; &#125; &#125; &#125; &#125; // 随机 level 次，如果是奇数层数 +1，防止伪随机 private int randomLevel() &#123; int level = 1; for (int i = 1; i &lt; MAX_LEVEL; ++i) &#123; if (r.nextInt() % 2 == 1) &#123; level++; &#125; &#125; return level; &#125; //打印全部数据 public void printAll() &#123; Node p = head; while (p.forwards[0] != null) &#123; System.out.print(p.forwards[0] + \" \"); p = p.forwards[0]; &#125; System.out.println(); &#125; //定义节点 public class Node &#123; private int data = -1; private Node forwards[] = new Node[MAX_LEVEL]; private int maxLevel = 0; @Override public String toString() &#123; StringBuilder builder = new StringBuilder(); builder.append(\"&#123; data: \"); builder.append(data); builder.append(\"; levels: \"); builder.append(maxLevel); builder.append(\" &#125;\"); return builder.toString(); &#125; &#125;&#125; redis 有序集合使用跳表的原因更容易实现相比红黑树更加易懂、好写，可读性更好。Ps:很多编程语言 Map 类型都是使用红黑树实现的。 更加灵活可以通过改变索引构建策略，有效平衡执行效率和内存消耗","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构与算法(七)——散列表（哈希表）","slug":"20190510-数据结构-散列表","date":"2019-04-29T06:30:07.000Z","updated":"2019-05-12T04:33:51.754Z","comments":true,"path":"text/dataStructure7.html","link":"","permalink":"http://yoursite.com/text/dataStructure7.html","excerpt":"","text":"散列表介绍散列表（Hash Table，也叫哈希表）：是根据关键码值(Key value)而直接进行访问的数据结构。 通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。 散列表的插入、查找和删除跟数组类似，根据散列冲突的解决方式有所不同 装载因子（load factor）表示散列表中空位的多少。散列表的装载因子 = 填入表中的元素个数 / 散列表的长度装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。 当散列表的装载因子超过某个阈值时，就需要进行扩容；在装载因子小于某个值之后，启动动态缩容。 散列函数散列函数就是将 key 转换成散列表下标的函数。 设计要求 散列函数计算得到的散列值是一个非负整数； 如果 key1 = key2，那 hash(key1) == hash(key2)； 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。 好的散列函数 散列函数的设计不能太复杂 散列函数生成的值要尽可能随机并且均匀分布 设计方法数据分析法、直接寻址法、平方取中法、折叠法、随机数法 散列冲突两个不同的 key 通过散列函数得到相同的 hashCode(散列值)，即为散列冲突。 散列冲突的解决方法：开放寻址法（open addressing）和链表法（chaining）当数据量比较小、装载因子小的时候，适合采用开放寻址法；存储大对象、大数据量的散列表适合使用链表法。 开放寻址法开放寻址法：出现了散列冲突，我们就重新探测一个空闲位置，将其插入。 优点：散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度；序列化简单。缺点：删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据；装载因子的上限不能太大，比链表法更浪费内存空间。 线性探测（Linear Probing）插入：当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。 查找：我们通过散列函数求出要查找元素的键值对应的 散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的 元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元 素并没有在散列表中。 删除：删除比较特殊，直接删除数据会导致原来的查找算法失效，所以要将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空 间，并不是停下来，而是继续往下探测。 缺点：散列表插入数值越多，散列冲突发生概率越高，需要探测的时间越久。插入、查找和删除的时间复杂度趋向于 O(n)。 二次探测（Quadratic probing）二次探测与线性探测类似，线性探测每次探测的步长是 1，而二次探测探测的步长就变成了原来的“二次方”。 双重散列（Double hashing）使用多组散列函数计算 hashCode，我们先用第一个散列函数，如果计算得到的存储位置已经被 占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。 不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽 可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。 链表法将所有哈希地址相同的都链接在同一个链表中 ，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。 优点：内存的利用率比开放寻址法要高，对大装载因子的容忍度更高；比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。缺点：比较小的对象的存储，内存消耗大；存储大对象内存消耗忽略不计。 插入：只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，时间复杂度是 O(1)。 查找、删除：通过散列函数计算出对应的槽， 然后遍历链表查找或者删除。这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。 工业级的散列表特性 持快速的查询、插入、删除操作； 内存占用合理，不能浪费过多的内存空间； 性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。 设计思路 设计一个合适的散列函数； 定义装载因子阈值，并且设计动态扩容策略； 选择合适的散列冲突解决方法。 应用Word 文档中单词拼写检查功能用散列表来存储整个英文单词词典（常用的英文单词有 20 万个左右，1 个字符占用 1 个字节，最多占用 20MB）。当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正 确；如果没有查到，则说明拼写可能有误，给予提示。 java 中的HashMapHashMap 底层采用链表法来解决冲突。在 JDK1.8 版本中，为了对 HashMap 做进一步优化，我们引入了红黑树。而当链表长度太 长（默认超过 8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构与算法(五)——递归","slug":"20190425-数据结构-递归","date":"2019-04-25T06:30:07.000Z","updated":"2019-04-25T08:09:50.000Z","comments":true,"path":"text/dataStructure5.html","link":"","permalink":"http://yoursite.com/text/dataStructure5.html","excerpt":"","text":"递归介绍递归（Recursion）：一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如 DFS 度优先搜索、前中后序二叉树遍历、IDE 的单步跟踪功能等都是使用递归。 方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。 基本上，所有的递归问题都可以用递推公式来表示，比如123f(n) = f(n-1) + 1 ,f(1)=1;f(n) = f(n-1) + f(n-2);f(n) = n*f(n-1); 优点：代码的表达力很强，写起来简洁。缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。 使用递归的条件1.问题的解可以分解为几个子问题（数据规模更小的问题）的解2.问题与子问题，除了数据规模不同，求解思路完全一样3.存在递归终止条件 如何实现递归递归代码编写写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。 递归代码理解对于递归代码，若试图想清楚整个递和归的过程，实际上是进入了一个思维误区。 如果一个问题A可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。 因此，理解递归代码，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。 递归常见问题及解决方案警惕堆栈溢出可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。 警惕重复计算通过某种数据结构来保存已经求解过的值，从而避免重复计算。 将递归改写为非递归代码所有的递归代码都可以改写为迭代循环的非递归写法抽象出递推公式、初始值和边界条件，然后用迭代循环实现 调试递归打印日志发现，递归值结合条件断点进行调试 算法斐波拉契数列1234567891011/* 斐波那契数列: 0、1、1、2、3、5、8 可以这样理解 f0 = 0; f1 = 1; fn = f(n-1) + f(n - 2) （n &gt;= 2）*/ public static int f(int n) &#123; if (n == 1 || n == 2) &#123; return 1; &#125; else &#123; return f(n - 1) + f(n - 2); &#125;&#125; 求阶乘n123456789101112public int doFactorial(int n)&#123; if(n&lt;0)&#123; return -1;//传入的数据不合法 &#125; if(n==0)&#123; return 1; &#125;else if(n==1)&#123;//递归结束的条件 return 1; &#125;else&#123; return n*doFactorial(n-1); &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构与算法(四)——队列","slug":"20190411-数据结构-队列","date":"2019-04-11T01:30:07.000Z","updated":"2019-04-11T03:37:50.000Z","comments":true,"path":"text/dataStructure4.html","link":"","permalink":"http://yoursite.com/text/dataStructure4.html","excerpt":"","text":"队列(Queue)：具有先进先出的特性，支持在队尾插入元素，在队头删除元素的特性。 队列是一种操作受限的线性表数据结构，包含两个操作，入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。 用数组实现的队列，我们叫作顺序队列，用链表实现的队列，我们叫作链式队列。 队列的数组实现12345678910111213141516171819202122232425262728293031323334353637383940// 用数组实现的队列public class ArrayQueue &#123; // 数组：items，数组大小：n private String[] items; private int n = 0; // head 表示队头下标，tail 表示队尾下标 private int head = 0; private int tail = 0; // 申请一个大小为 capacity 的数组 public ArrayQueue(int capacity) &#123; items = new String[capacity]; n = capacity; &#125; // 入队操作，将 item 放入队尾 public boolean enqueue(String item) &#123; // tail == n 表示队列末尾没有空间了 if (tail == n) &#123; // tail ==n &amp;&amp; head==0，表示整个队列都占满了 if (head == 0) return false; // 数据搬移 for (int i = head; i &lt; tail; ++i) &#123; items[i-head] = items[i]; &#125; // 搬移完之后重新更新 head 和 tail tail -= head; head = 0; &#125; items[tail] = item; ++tail; return true; &#125; // 出队 public String dequeue() &#123; // 如果 head == tail 表示队列为空 if (head == tail) return null; String ret = items[head]; ++head; return ret; &#125;&#125; 队列的链表实现1234567891011121314151617181920212223242526272829303132public class LinkedQueue &#123; private Node head = null; private Node tail = null; private static class Node &#123; int value; Node next; public Node(int value) &#123; this.value = value; this.next = null; &#125; &#125; public boolean enqueue(int value) &#123; Node newNode = new Node(value); if (head == null) &#123; head = newNode; tail = newNode; &#125; else &#123; tail.next = newNode; tail = newNode; &#125; return true; &#125; public int dequeue() &#123; if (head == null) &#123; return -1; &#125; Node node = head.next; int value = node.value; head = node; return value; &#125;&#125; 循环队列具有队头指针和队尾指针，指示队列元素所在的位置，避免删除元素时移动大量元素。 123456789101112131415161718192021222324252627public class CircularQueue &#123; // 数组：items，数组大小：n private String[] items; private int n = 0; // head 表示队头下标，tail 表示队尾下标 private int head = 0; private int tail = 0; // 申请一个大小为 capacity 的数组 public CircularQueue(int capacity) &#123; items = new String[capacity]; n = capacity; &#125; // 入队 public boolean enqueue(String item) &#123; // 队列满了 if ((tail + 1) % n == head) return false; items[tail] = item; tail = (tail + 1) % n; return true; // 出队 // 如果 head == tail 表示队列为空 if (head == tail) return null; String ret = items[head]; head = (head + 1) % n; return ret; &#125;&#125; 阻塞队列阻塞队列其实就是在队列基础上增加了阻塞操作。在队列为空的时候，从队头取数据会被阻塞；队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。 生产者 - 消费者模型当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。 并发队列线程安全的队列我们叫作并发队列。 直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。 问题线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？两种处理策略;第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理 队列两种实现方式对于排队请求有什么区别呢？基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。 而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。 对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构与算法(三)——栈","slug":"20190410-数据结构-栈","date":"2019-04-10T13:29:07.000Z","updated":"2019-04-11T02:11:14.000Z","comments":true,"path":"text/dataStructure3.html","link":"","permalink":"http://yoursite.com/text/dataStructure3.html","excerpt":"","text":"栈(Stack)：当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性。 栈是一种操作受限的线性表数据结构，包含两个操作，入栈 push()和出栈 pop()，也就是在栈顶插入一个数据和从栈顶删除一个数据。 用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。 栈的数组实现123456789101112131415161718192021222324252627282930// 基于数组实现的顺序栈public class ArrayStack &#123; private String[] items; // 数组 private int count; // 栈中元素个数 private int n; // 栈的大小 // 初始化数组，申请一个大小为 n 的数组空间 public ArrayStack(int n) &#123; this.items = new String[n]; this.n = n; this.count = 0; &#125; // 入栈操作 public boolean push(String item) &#123; // 数组空间不够了，直接返回 false，入栈失败。 if (count == n) return false; // 将 item 放到下标为 count 的位置，并且 count 加一 items[count] = item; ++count; return true; &#125; // 出栈操作 public String pop() &#123; // 栈为空，则直接返回 null if (count == 0) return null; // 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一 String tmp = items[count-1]; --count; return tmp; &#125;&#125; 栈的链表实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class StackOfLinked&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; //定义一个内部类，就可以直接使用类型参数 private class Node&#123; Item item; Node next; &#125; private Node first; private int N; //构造器 public StackOfLinked()&#123;&#125; //添加 public void push(Item item)&#123; Node oldfirst = first; first = new Node(); first.item = item; first.next = oldfirst; N++; &#125; //删除 public Item pop()&#123; Item item = first.item; first = first.next; N--; return item; &#125; //是否为空 public boolean isEmpty()&#123; return N == 0; &#125; //元素数量 public int size()&#123; return N; &#125; //返回栈中最近添加的元素而不删除它 public Item peek()&#123; return first.item; &#125; public Iterator&lt;Item&gt; iterator() &#123; return new LinkedIterator(); &#125; //内部类：迭代器 class LinkedIterator implements Iterator&#123; int i = N; Node t = first; public boolean hasNext() &#123; return i &gt; 0; &#125; public Item next() &#123; Item item = (Item) t.item; t = t.next; i--; return item; &#125; &#125;&#125; 应用场景函数调用栈操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈 栈在表达式求值中的应用如：34+13*9+44-12/3两个栈对象，一个存操作数，一个存计算符，遇到运算符，就与运算符栈的栈顶元素进行比较，若比运算符栈顶元素优先级高，就将当前运算符压入栈，若比运算符栈顶元素的优先级低或者相同，从运算符栈中取出栈顶运算符，从操作数栈顶取出2个操作数，然后进行计算，把计算完的结果压入操作数栈，继续比较 栈在括号匹配中的应用如：{}{()}用栈保存为匹配的左括号，从左到右一次扫描字符串，当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号，如果能匹配上，则继续扫描剩下的字符串。如果扫描过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。 当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明未匹配的左括号为非法格式 实现浏览器的前进后退功能使用两个栈X和Y，我们把首次浏览的页面依次压如栈X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据一次放入Y栈。当点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，说明没有页面可以继续后退浏览了。当Y栈没有数据，那就说明没有页面可以点击前进浏览了","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"“耐性”不要太好","slug":"20190317-“耐性”不要太好","date":"2019-03-17T14:47:09.000Z","updated":"2019-03-17T15:35:30.000Z","comments":true,"path":"text/feeling.html","link":"","permalink":"http://yoursite.com/text/feeling.html","excerpt":"","text":"前几天玩微信，发现了“浮窗”这个小功能，刚好解决了一个我很不爽的问题。 我看公众号文章比较多，经常有人发信息给我而我正在看公众号文章，那我就不得不退出去回复信息再点回来继续看，但这来回看文章又要好多个步骤，很麻烦，也很厌烦。“浮窗”功能是将公众号文章缩小成为浮窗，显示在界面上，然后我们可以任意切换其它的微信界面，点击浮窗直接查看文章，刚好解决了我的问题。具体的操作说明在这里就不说了。 可能我“耐性”真的好，硬是忍了这么久。要不是前几天无意间发现“浮窗”这个功能，我都不知道会持续到什么时候。 刚发现时还以为是新上线的功能呢，兴冲冲地跑去查了一下，结果这个功能去年5月份上线的，将近一年时间了。此时我才真正的反思自己。 功能上线快一年，还可以解释为对产品功能不关注，但我已经明显用得不爽了，却一直忍受着，为什么不去寻找解决方法呢？真的是“耐性”好吗？不是的，我觉察到了，但根本没有意识到要去改变它，这是一个非常不好的状况。警醒！ 作为一个程序员，追求「极客精神」，这篇文章作为自己的一个警醒，努力变得更好！","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[],"keywords":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}]},{"title":"生活急救常识","slug":"20190314-生活急救常识","date":"2019-03-14T14:47:09.000Z","updated":"2019-03-16T11:06:24.000Z","comments":true,"path":"text/firstAid.html","link":"","permalink":"http://yoursite.com/text/firstAid.html","excerpt":"","text":"上周末，公司组织了一次关于生活急救常识的培训，收获很大，觉得有必要记录下来，牢牢掌握。 烧伤急救 烧伤：因接触热、电或化学物质引起的创伤。烧伤分类：热源、雷电、热液体、化学品、电流。 开水烫伤1.用大量的流水（注意水流，不要过大）持续冲洗降温，持续大约20分钟左右，让患处温度与周边正常皮肤温度一致。2.局部轻度红肿或出现少量水泡（轻度烫伤），可在冲泡后，用烫伤药均匀涂抹，之后用无菌纱布或干净的纯棉毛巾覆盖于伤口并固定；3.严重的紧急处理后赶快就医。 忌冰敷：不可以直接冰敷，以免冻伤。用酱油涂：伤口上撒盐，会加重伤逝。牙膏涂抹：牙膏会使皮肤热气无处散发。用白酒冲洗伤口：皮肤未破溃时有一定降温效果；皮肤已破溃会加重疼痛，加深创面。 明火烧伤若衣服着火，卧倒在地滚压灭火，或用水浇灭火焰。 烧伤急救五字要诀，“冲、脱、泡、包、送” 冲：用清水冲洗烧伤创面；脱：边冲边用轻柔的动作脱掉烧伤者的外衣，如果衣服粘住皮肉，不能强扯，可以用剪刀剪开；泡：用冷水浸泡创面；包：用干净的布单、衣物包扎伤处，有纱布最好；送：尽快送到具有救治烧伤经验的医院治疗。 当然就医一般看烧伤情况。 电击烧伤1.先将电源切断，或用绝缘体将电源移开，如干木棒、树枝、扫帚柄等。电源不明时，切记不要直接用手接触触电者。2.在浴室或潮湿的地方，救护人要穿绝缘胶鞋戴胶皮手套或站在干燥木板上以保护自身安全。3.如伤员无心跳、呼吸，拨打120呼叫救护车，并立即施行心肺复苏术，不要轻易放弃，一直坚持到医生护士到来为止。4.局部烧伤病人应马上降温，然后就地取材进行创面的简易包扎，再送医院救治。 窒息急救 窒息：是指异物卡在咽喉部位气道处导致出现窒息的状况。分为轻度异物堵塞和重度异物堵塞。 鱼刺卡喉吃鱼难免会遇到鱼刺卡到喉咙，所以正确处理很重要。鱼刺如上图所示，一个三叉形状，一般鱼刺卡喉都是因为鱼刺倒叉在喉咙上。 生活中很多处理方法都是错误的，如大口吞饭、大口喝水、大口喝醋，这些方法只会让鱼刺扎得越深，即使解决问题也会让食道受伤。 正确方式：轻微的咳嗽出来就好，再者张开嘴让亲友夹出来，严重得请及时到医院就医 轻度异物堵塞可以说话或发出声音、可以大声咳嗽。咳嗽将异物咳出就好。 重度度异物堵塞无法呼吸、说话或者发出声音、有窒息的感觉。立即采取急救方法处理。 海姆立克急救法（腹部冲击法）:急救者首先以前腿弓，后腿登的姿势站稳，然后使患者坐在自己弓起的大腿上，并让其身体略前倾。然后将双臂分别从患者两腋下前伸并环抱患者。左手握拳，右手从前方握住左手手腕，使左拳虎口贴在患者胸部下方，肚脐上方的上腹部中央，形成“合围”之势，然后突然用力收紧双臂，用左拳虎口向患者上腹部内上方猛烈施压，迫使其上腹部下陷。这样由于腹部下陷，腹腔内容上移，迫使膈肌上升而挤压肺及支气管，这样每次冲击可以为气道提供一定的气量，从而将异物从气管内冲出。施压完毕后立即放松手臂，然后再重复操作，直到异物被排出。 动物咬伤猫狗咬伤清理伤口伤口不大，用肥皂水和清水交替清洗伤口 15 分钟，用碘伏和酒精消毒，不要包扎；咬伤严重，那就赶快直接送医院。 判断是否要注射疫苗1.如果被不知哪来的流浪猫狗咬伤、抓伤，是百分百要注射疫苗的。2.如果是被宠物猫狗咬伤、抓伤，就要具体看了。 怎么判断咬你的猫猫狗狗有没有狂犬病呢？「十日观察法」猫狗只有感染了病毒，在发病前几天才有传染性，而狂犬病病毒凶猛，一旦发病，短则三五日，长则十日，这个猫狗也是要口吐白沫而死的。被猫狗咬伤，如果 10 天之后，这只猫或者狗安然无恙，那么基本可以判定，猫狗是健康的，自己没有感染狂犬病毒。 狂犬病 狂犬病病毒是一种嗜神经病毒，并不是通过血液传染，只要皮肤破损，就能感染。病毒沿着人的外周神经直捣中枢神经系统，引发神经病变。狂犬病的发病很快，死亡率几乎百分百，一旦发病，没得治，3～5 天就会死亡。 狂犬病的潜伏期并不长，通常是 1～3 个月，最短的不到 1 周，极少数会超过 1 年，而不是传闻中的 20 年。没被咬出血，也会感染狂犬病病毒；现阶段狂犬病没法治，只能注射疫苗；不仅猫和狗会携带狂犬病病毒，很多家畜和野生动物都会携带。 蜜蜂蜇伤1.刮掉毒刺、毒囊；2.用大量肥皂水冲洗伤口；3.因为体质问题，有些人会出现呼吸困难、伤口红肿、呕吐或腹泻等症状，请立即去医院就医。 流鼻血流鼻血一般是鼻粘膜或毛细血管破裂导致。 错误方法：仰头，塞纸巾在鼻孔里。 正确方式：低头前倾，压按鼻翼止血。 心肺复苏术心搏骤停一旦发生，如得不到即刻及时地抢救复苏，4～6min后会造成患者脑和其他人体重要器官组织的不可逆的损害，因此心搏骤停后的心肺复苏（cardiopulmonary resuscitation, CPR）必须在现场立即进行。 胸外心脏按压按压位置：胸骨中、下1/3交界处的正中线上或剑突上2.5～5cm处（一般是两乳头连线中间处）；手掌根部紧放在按压部位，两手平行重叠且手指交叉互握抬起，使手指脱离胸壁。 按过模型，这是个体力活，真的累！ 好人法 《中华人民共和国民法总则》第184条于2017年3月15日，第十二届全国人民代表大会第五次会议通过。规定：“因自愿实施紧急救助行为造成受助人损害的，救助人不承担民事责任。” 好人法，善意救助者责任豁免！","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[],"keywords":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}]},{"title":"数据结构与算法(二)——数组、链表","slug":"20190221-数据结构-数组-链表","date":"2019-02-21T09:29:07.000Z","updated":"2019-03-14T13:03:16.000Z","comments":true,"path":"text/dataStructure2.html","link":"","permalink":"http://yoursite.com/text/dataStructure2.html","excerpt":"","text":"常用数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Tire树(字典树)线性表结构：数组、链表、栈、队列、散列表非线性表：二叉树、堆、图、树 线性表（Linear List）是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向。非线性表，数据之间并不是简单的前后关系。 数据结构的特性 数组 数组是一种线性表数据结构；它用一组连续的内存空间，来存储一组具有相同类型的数据。连续的内存空间、相同的数据类型，所以数组可以随机访问，但对数组进行删除插入，为了保证数组的连续性，就要做大量的数据搬移工作。数组都是从 0 开始编号的，从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。 数组适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好的数组，用二分查找，时间复杂度也是O（logn）。数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。 优点：简单易用，查找快缺点：大小固定，增删慢 数组如何实现下标随机访问？例：长度为 10 的 int 类型的数组 int[] a = newint[10]，计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address =1000。计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：$$a[i]_address = base_address + i * data_type_size$$data_type_size 表示数组中每个元素的大小。 容器的优劣相比于数组，java 中的 ArrayList 将很多数组操作的细节封装起来，并支持动态扩容。一旦超过存储容量，扩容时比较耗内存，因为涉及到内存申请和数据搬移。 数组适合的场景1.Java ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别关注性能，可以考虑数组2.若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组。3.表示多维数组时，数组往往更加直观。4.业务开发容器即可，底层开发，如网络框架，性能优化。选择数组。 链表 从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。链表通过指针将一组零散的内存块串联在一起，内存块称为链表的“结点”(Node 存储数据、记录链上的下一个结点的地址),后继指针(next)用来记录下个结点地址的指针。 优点：增删快 O(1)，支持动态扩容缺点：查找慢 O(n)，内存空间消耗大，频繁增删，容易造成冗余 三种最常见的链表结构：单链表、双向链表和循环链表 单链表每个节点只包含一个指针，即后继指针。单链表有两个特殊的节点，即头节点和尾节点。头结点用来记录链表的基地址，尾结点指向一个空地址 NULL，表示这是链表上最后一个结点。 循环链表除了尾节点的后继指针指向首节点的地址外均与单链表一致。适用于存储有循环特点的数据，比如约瑟夫问题。 双向链表节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针 prev）和下一个节点地址（后继指针 next），首节点的前驱指针 prev 和尾节点的后继指针均指向空地址 双向循环链表首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点 比较 时间复杂度 数组 链表 随机访问 $$O(1)$$ $$O(n)$$ 插入删除 $$O(n)$$ $$O(1)$$ 应用LRU 缓存策略 缓存是一种提高数据读取性能的技术。缓存的大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？就需要用到缓存淘汰策略。缓存淘汰策略是当缓存被用满时清理数据的优先顺序。 常见的三种缓存淘汰策略先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frenquently Used）、最近最少使用策略 LRU（Least Recently Used）。 链表实现 LRU当访问的数据没有存储在缓存的链表中时，直接将数据插入链表表头，时间复杂度为O(1)；当访问的数据存在于存储的链表中时，将该数据对应的节点，插入到链表表头,时间复杂度为O(n)。如果缓存被占满，则从链表尾部的数据开始清理，时间复杂度为O(1)。 PS:维护一个有序链表，尾部为最早访问的数据，头部为最新，现插入一数据1.遍历，查看数据是否存在2.1 存在，删除已有数据，将数据插入到头部2.2 不存在2.2.1 链表没满，直接插入到头部2.2.2 链表满了，删除链表尾节点，将数据插入头部 数组实现 LRU1.首位置保存最新访问数据，末尾位置优先清理当访问的数据未存在于缓存的数组中时，直接将数据插入数组第一个元素位置，此时数组所有元素需要向后移动1个位置，时间复杂度为O(n)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉末尾的数据，时间复杂度为O(1)。 2.首位置优先清理，末尾位置保存最新访问数据当访问的数据未存在于缓存的数组中时，直接将数据添加进数组作为当前最有一个元素时间复杂度为O(1)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入当前数组最后一个元素的位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉数组首位置的元素，且剩余数组元素需整体前移一位，时间复杂度为O(n)。（优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。） 链表回文串验证使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if (head == null || head.next == null) &#123; return true; &#125; ListNode prev = null; ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; ListNode next = slow.next; slow.next = prev; prev = slow; slow = next; &#125; if (fast != null) &#123; slow = slow.next; &#125; while (slow != null) &#123; if (slow.val != prev.val) &#123; return false; &#125; slow = slow.next; prev = prev.next; &#125; return true; &#125;&#125; 时空替换思想时空替换思想：“用空间换时间” 与 “用时间换空间”当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高，时间复杂度小相对较低的算法和数据结构，缓存就是空间换时间的例子。如果内存比较紧缺，比如代码跑在手机或者单片机上，这时，就要反过来用时间换空间的思路。 「空间换时间」某些情况下”双向链表”替代”单向链表”；缓存","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构与算法(一)——复杂度分析","slug":"20190220-数据结构-复杂度分析","date":"2019-02-20T09:29:07.000Z","updated":"2019-07-19T08:23:23.239Z","comments":true,"path":"text/dataStructure1.html","link":"","permalink":"http://yoursite.com/text/dataStructure1.html","excerpt":"","text":"介绍 数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。数据结构是为算法服务的，算法要作用在特定的数据结构之上。 数据结构与算法中最重要的概念：复杂度分析最常用、最基础的 20 个数据结构与算法：数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Tire树(字典树)算法： 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法、排序算法 复杂度分析复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。复杂度分析表示效率和资源消耗的度量衡。 为什么要进行复杂度分析1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。 复杂度分析法则1.单段代码看高频：比如循环。2.多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。3.嵌套代码求乘积：比如递归、多重循环等4.多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。 大 O 复杂度表示法算法的执行时间 T(n) 与每行代码的执行次数 n 成正比$$T(n) = O( f(n) )$$ T(n)：代码执行的时间； n：表示数据规模的大小； f(n)：表示每行代码执行的次数总和 12345678int cal(int n) &#123; int sum = 0; // 1 int i = 1; // 1 for (; i &lt;= n; ++i) &#123; // n sum = sum + i; // n &#125; return sum;&#125; $$时间复杂度为：T(n) = O(2n+2)$$ 当 n 很大时，公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。 $$T(n) = O(2n+2) -&gt; T(n) =O(n)$$ 时间复杂度大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。 判断依据只关注循环执行次数最多的一段加法法则：总复杂度等于量级最大的那段代码的复杂度乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的积 复杂度量级 常量阶 $$O(1)$$ 指数阶 $$O(2^n)$$ 对数阶 $$O(logn)$$ 阶乘阶 $$O(n!)$$ 线性阶 $$O(n)$$ 线性对数阶 $$O(nlogn)$$ 平方阶 $$O(n^2)$$ 立方阶 $$O(n^3)$$ k次方阶 $$O(n^k)$$ 非多项式量级: O(2^n)和 O(n!) 时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。 当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。复杂度分析的4个概念1.最好情况时间复杂度（best case time complexity）：代码在最理想情况下执行的时间复杂度 O(1)。2.最坏情况时间复杂度（worst case time complexity）：代码在最坏情况下执行的时间复杂度 O(n)。3.平均情况时间复杂度（average case time complexity）：代码在所有情况下执行的次数的加权平均值表示，代码在不同情况下复杂度出现量级差别时使用。4.均摊时间复杂度（amortized time complexity）：代码在大部分情况下时间复杂度都很低，个别情况下时间复杂度比较高，操作之间存在前后连贯的时序关系，将较高时间复杂度的耗时，平摊到时间复杂度比较低的操作上。基本上均摊结果就等于低级别复杂度 O(1)。(使用摊还分析法计算) 为什么要引入这4个概念？1.同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。2.代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。 空间复杂度空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。空间复杂度是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。复杂度判断与时间复杂度类似，一般复杂度量级为：O(1)、O(n)、O(n^2)。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"知识的诅咒","slug":"20190215-知识的诅咒","date":"2019-02-15T01:47:53.000Z","updated":"2019-03-14T13:03:00.000Z","comments":true,"path":"text/knowledgeCurse.html","link":"","permalink":"http://yoursite.com/text/knowledgeCurse.html","excerpt":"","text":"什么是知识的诅咒 维基百科：一种认知偏差，当个体与其他个体交流时，他们会在不知不觉中假设其他人有理解的背景。 我们一旦知道了某事，就无法想象这件事在未知者眼中的样子。当我们把自己知道的知识解释给别人的时候，因为信息的不对等，我们很难把自己知道的完完全全给对方解释清楚。总之，我们的知识“诅咒”了我们。我们所认为的常识，可能就是别人的信息盲点。（信息不对称，既是商机也可能是一种沟通障碍） 表现形式学计算机的难以理解连百度都不会用的人如何生活。在我们享受 4G 时，如何体会尚未上过网的 5 亿中国人如何思考（《中国互联网络发展状况统计报告》统计显示，截至 2018年6月，中国网民规模为8.02亿，中国人口 13.9 亿，差额 5 亿多人） 当你知道某个知识，你就很难明白不知道这个知识的人到底是什么状态。或者你学会了某个技能你也完全忘了没会前是什么样子，好像从一开始就会一样。如果你不会一个东西，你往往会认为，会的人好厉害。 如何打破1. 扩大自己的圈子了解不同行业的人是如何在不同层面思考问题，缩小认知偏差。 2. 简化概念简单直白的话更易于理解。在给非专业较低水平的人交流时，不要长篇大论，也不应该过于深入的解读，我们要做的是让他们了解，而不是理解。 3. 用场景代替抽象名词善用比喻和故事，让听的人自己在场景中感受，而不是强加我们的理解认识给他们。 看见差异，尊重差异","categories":[{"name":"阅读","slug":"阅读","permalink":"http://yoursite.com/categories/阅读/"}],"tags":[],"keywords":[{"name":"阅读","slug":"阅读","permalink":"http://yoursite.com/categories/阅读/"}]},{"title":"Spring Boot 使用 Spring Security (二)","slug":"20190130-springSecurity权限校验","date":"2019-01-30T12:38:46.000Z","updated":"2019-03-14T13:02:52.000Z","comments":true,"path":"text/springSecurity2.html","link":"","permalink":"http://yoursite.com/text/springSecurity2.html","excerpt":"","text":"介绍 使用 springboot+mybatis＋SpringSecurity 实现数据库动态的管理用户、角色、权限管理。 细分角色和权限，并将用户、角色、权限和资源均采用数据库存储，并且自定义滤器，代替原有的FilterSecurityInterceptor过滤器，并分别实现 AccessDecisionManager、InvocationSecurityMetadataSourceService 和 serDetailsService，并在配置文件中进行相应配置。 数据库表设计12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#创建用户表create table user( id int not null primary key comment'主键id', username varchar(50) not null comment'用户名', password varchar(50) not null comment'密码')#角色表create table role( id int not null primary key comment'主键id', name varchar(50) not null comment'角色名')#用户角色表create table user_role( user_id varchar(50) not null comment'用户id', role_id varchar(50) not null comment'角色id')#权限表create table permission ( id int unsigned not null auto_increment comment'主键id', name varchar (200) not null comment'角色名', description varchar (200) default null comment'描述', url varchar (200) not null comment'路径', pid int default null comment'上级id', primary key (id))#角色权限中间表create table permission_role ( id int unsigned not null auto_increment comment'主键id', role_id int unsigned not null comment'角色id', permission_id int unsigned not null comment'权限id', primary key (id))#插入用户INSERT INTO user(id,username,password)VALUES('1',admin','admin');INSERT INTO user(id,username,password)VALUES('2',user','user');INSERT INTO user(id,username,password)VALUES('3',test','test');#插入角色INSERT INTO role VALUES ('1', 'ROLE_ADMIN'); INSERT INTO role VALUES ('2', 'ROLE_USER'); INSERT INTO user_role VALUES ('1', '1'); INSERT INTO user_role VALUES ('1', '2'); INSERT INTO user_role VALUES ('2', '2'); INSERT INTO permission VALUES ('1', 'ROLE_USER', 'user', '/admin/home', null);INSERT INTO permission_role VALUES ('1', '2', '1')); 项目结构 引入 maven 依赖pom 文件123456789101112131415161718192021222324252627282930313233343536373839404142&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql版本根据自身情况调整--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--thymeleaf页面展示控制--&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity4&lt;/artifactId&gt; &lt;version&gt;3.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置数据库信息123456789spring.datasource.url=jdbc:mysql://localhost:3306/worldspring.datasource.username=rootspring.datasource.password=123456spring.jpa.database=mysqlspring.datasource.driver-class-name=com.mysql.jdbc.Driverserver.port=8088 mybatis.mapper-locations=classpath:UserMapper.xml 创建 pojo/dao/mapper/controller 文件PS: 功能比较简单，所以省略 service 文件，直接调用 dao 层文件；并将权限表的相关查询操作写在同一 mapper 文件 User.java12345678public class User &#123; private int id; private String username; private String password; private List&lt;Role&gt; roles; /* Getter 和 Setter 自行补充 */&#125; Role.java123456public class Role &#123; private int id; private String name; /* Getter 和 Setter 自行补充 */&#125; Permission.java12345678910111213public class Role &#123; private int id; //权限名称 private String name; //权限描述 private String descritpion; //授权链接 private String url; //父节点id private int pid; /* Getter 和 Setter 自行补充 */&#125; UserMapper.java 12345678910@Mapper@Repositorypublic interface UserMapper &#123; //根据用户名查找用户所有权限信息 User findByUserName(String username); //获取所有权限信息 List&lt;Permission&gt; findAllPermission(); // List&lt;Permission&gt; findByAdminUserId(int userId);&#125; UserMapper.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.xeh.security.dao.UserMapper\"&gt; &lt;resultMap id=\"userMap\" type=\"com.xeh.security.model.User\"&gt; &lt;id property=\"id\" column=\"ID\"/&gt; &lt;result property=\"username\" column=\"username\"/&gt; &lt;result property=\"password\" column=\"PASSWORD\"/&gt; &lt;collection property=\"roles\" ofType=\"com.xeh.security.model.Role\"&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findByUserName\" parameterType=\"String\" resultMap=\"userMap\"&gt; select u.* ,r.name from user u LEFT JOIN user_role sru on u.id = sru.user_id LEFT JOIN role r on sru.role_id = r.id where username = #&#123;username&#125; &lt;/select&gt; &lt;select id=\"findAllPermission\" resultType=\"com.xeh.security.model.Permission\"&gt; select * from permission &lt;/select&gt; &lt;select id=\"findByAdminUserId\" parameterType=\"int\" resultType=\"com.xeh.security.model.Permission\"&gt; select p.* from user u left join user_role sru on u.id = sru.user_id left join role r on sru.role_id = r.id left join permission_role spr on spr.role_id = r.id left join permission p on p.id = spr.permission_id where u.id = #&#123;userId&#125; &lt;/select&gt;&lt;/mapper&gt; HelloController.java1234567891011121314151617@Controllerpublic class HelloController &#123; @RequestMapping(\"/admin/hello\") public String index()&#123; return \"hello\"; &#125; @RequestMapping(value =&#123;\"\",\"/\",\"/home\"&#125;) public String home()&#123; return \"home\"; &#125; @RequestMapping(\"/login\") public String login()&#123; return \"login\"; &#125;&#125; 页面文件home.html1234567891011&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt;&lt;head&gt; &lt;title&gt;Spring Security Home&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;欢迎!&lt;/h1&gt;&lt;p&gt;点击 &lt;a th:href=\"@&#123;/admin/hello&#125;\"&gt;这里&lt;/a&gt;进入hello页面.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; hello.html123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt;&lt;head&gt; &lt;title&gt;Hello World!&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:inline=\"text\"&gt;Hello [[$&#123;#httpServletRequest.remoteUser&#125;]]!&lt;/h1&gt;&lt;div sec:authorize=\"isAuthenticated()\"&gt; &lt;!-- 用户认证通过才能才显示 --&gt; &lt;p&gt;用户名:&lt;span sec:authentication=\"name\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;权限:&lt;span sec:authentication=\"principal.authorities\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;div sec:authorize=\"hasRole('ADMIN')\"&gt; &lt;!-- 用户角色为“ADMIN”才显示 --&gt; &lt;p&gt;【管理员】才能看见的内容&lt;/p&gt;&lt;/div&gt;&lt;div sec:authorize=\"hasRole('USER')\"&gt; &lt;!-- 用户角色具有“USER”权限才显示 --&gt; &lt;p&gt;【普通用户】才能看到的内容&lt;/p&gt;&lt;/div&gt;&lt;form th:action=\"@&#123;/logout&#125;\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"注销\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; login.html12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:if=\"$&#123;param.error&#125;\"&gt; 用户名或密码错误&lt;/div&gt;&lt;div th:if=\"$&#123;param.logout&#125;\"&gt; 账户已退出登录&lt;/div&gt;&lt;form th:action=\"@&#123;/login&#125;\" method=\"post\" action=\"/login\"&gt; &lt;div&gt;&lt;label&gt; 用户名: &lt;input type=\"text\" name=\"username\"/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;label&gt; 密 码: &lt;input type=\"password\" name=\"password\"/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=\"submit\" value=\"登录\"/&gt;&lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 这样，我们就搭好了连接数据库的 springboot 项目，接下来就是添加权限了 流程图SpringSecurity 登录认证流程图 SpringSecurity 权限管理流程图 添加 SpringSecurity,实现登录及权限验证创建 Spring Security 的配置类 WebSecurityConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Configuration@EnableWebSecurity //使得Spring Security提供并且支持了Spring MVC的集成public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; //用户无权限拦截处理类 @Autowired private MyAccessDeniedHandler accessDeniedHandler; //授权管理 @Autowired private MyFilterSecurityInterceptor myFilterSecurityInterceptor; //注册UserDetailsService 的bean，通过用户名加载与该用户的用户名、密码以及权限相关的信息 @Bean UserDetailsService customUserService()&#123; //注册UserDetailsService 的bean return new CustomUserDetailService(); &#125; /*定义认证规则*/ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(customUserService()).passwordEncoder(new MyPasswordEncoder()); //user Details Service验证 &#125; /** * 对URL进行权限配置 * 该方法定义url的访问权限，登录路径，注销 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests() .antMatchers(\"/\", \"/home\").permitAll() //任何人(包括没有经过验证的)都可以访问\"/\"和\"/home\" //.antMatchers(\"/admin/**\").access(\"hasRole('USER')\") .anyRequest().authenticated() //所有其他的URL都需要用户进行验证 .and() // 配置被拦截时的处理 .exceptionHandling() //添加无权限时的处理 .accessDeniedHandler(accessDeniedHandler) .and() .formLogin() //使用Java配置默认值设置了基于表单的验证。使用POST提交到\"/login\"时，需要用\"username\"和\"password\"进行验证 .loginPage(\"/login\") //指定在需要登录时将用户发送到的URL .permitAll() //用户可以访问formLogin()相关的任何URL .and() .logout() //注销 .permitAll(); //用户可以访问logout()相关的任何URL //权限控制 Filter http.addFilterBefore(myFilterSecurityInterceptor, FilterSecurityInterceptor.class); &#125; /*忽略静态资源*/ /*@Override public void configure(WebSecurity web) &#123; web.ignoring().antMatchers(\"/resources/static/**\"); &#125;*/&#125; 实现 UserDetailsService（认证管理器）自定义UserDetailsService 接口(认证管理器)，储存用户所有角色1234567891011121314151617181920212223242526272829303132@Servicepublic class CustomUserDetailService implements UserDetailsService &#123; @Autowired private UserMapper usersMapper; /** * 通过用户名加载与该用户的用户名、密码以及权限相关的信息 * @param username * @return * @throws UsernameNotFoundException */ @Override public UserDetails loadUserByUsername(String username) throws DisabledException &#123; User user = usersMapper.findByUserName(username); if (user != null) &#123; List&lt;Permission&gt; permissions = usersMapper.findByAdminUserId(user.getId()); List&lt;GrantedAuthority&gt; grantedAuthorities = new ArrayList &lt;&gt;(); for (Permission permission : permissions) &#123; if (permission != null &amp;&amp; permission.getName()!=null) &#123; GrantedAuthority grantedAuthority = new SimpleGrantedAuthority(permission.getName()); //1：此处将权限信息添加到 GrantedAuthority 对象中，在后面进行全权限验证时会使用GrantedAuthority 对象。 grantedAuthorities.add(grantedAuthority); &#125; &#125; return new org.springframework.security.core.userdetails.User(user.getUsername(), user.getPassword(), grantedAuthorities); &#125; else &#123; //throw new UsernameNotFoundException(\"用户名不存在\"); throw new DisabledException(\"----&gt;UserName :\" + username + \" not found!\"); &#125; &#125;&#125; 实现 PasswordEncoder（加密类）spring security 版本在 5.0 后要添加 PasswordEncoder 验证1234567891011public class MyPasswordEncoder implements PasswordEncoder &#123; @Override public String encode(CharSequence charSequence) &#123; return charSequence.toString(); &#125; @Override public boolean matches(CharSequence charSequence, String s) &#123; return s.equals(charSequence.toString()); &#125;&#125; 实现 AccessDeniedHandler (用户无权限处理器)用户无权限时处理类12345678910111213141516@Componentpublic class MyAccessDeniedHandler implements AccessDeniedHandler &#123; @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException &#123; //返回json形式的错误信息 response.setCharacterEncoding(\"UTF-8\"); response.setContentType(\"application/json\"); response.getWriter().println(\"&#123;\\\"code\\\":403,\\\"message\\\":\\\"你没有权限访问！\\\",\\\"data\\\":\\\"\\\"&#125;\"); response.getWriter().flush(); /*//无权限时跳转 response.sendRedirect(\"/home\"); */ request.getSession().invalidate(); //会话结束 &#125;&#125; 继承 AbstractSecurityInterceptor（资源管理拦截器）spring security 版本在 5.0 后要添加 PasswordEncoder 验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Servicepublic class MyFilterSecurityInterceptor extends AbstractSecurityInterceptor implements Filter &#123; //获取被拦截url所需的权限 @Autowired private FilterInvocationSecurityMetadataSource securityMetadataSource; //获取权限管理器 @Autowired public void setMyAccessDecisionManager(MyAccessDecisionManager myAccessDecisionManager) &#123; super.setAccessDecisionManager(myAccessDecisionManager); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; FilterInvocation fi = new FilterInvocation(request, response, chain); invoke(fi); &#125; public void invoke(FilterInvocation fi) throws IOException, ServletException &#123; //fi里面有一个被拦截的url //里面调用MyInvocationSecurityMetadataSource的getAttributes(Object object)这个方法获取fi对应的所有权限 //再调用MyAccessDecisionManager的decide方法来校验用户的权限是否足够 InterceptorStatusToken token = super.beforeInvocation(fi); try &#123; //执行下一个拦截器 fi.getChain().doFilter(fi.getRequest(), fi.getResponse()); &#125; finally &#123; super.afterInvocation(token, null); &#125; &#125; @Override public void destroy() &#123; &#125; @Override public Class&lt;?&gt; getSecureObjectClass() &#123; return FilterInvocation.class; &#125; @Override public SecurityMetadataSource obtainSecurityMetadataSource() &#123; return this.securityMetadataSource; &#125;&#125; 实现 FilterInvocationSecurityMetadataSource (读取url资源)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Servicepublic class MySecurityMetadataSource implements FilterInvocationSecurityMetadataSource &#123; @Autowired private UserMapper usersMapper; // 资源权限集合 private HashMap&lt;String, Collection&lt;ConfigAttribute&gt;&gt; map =null; /** * 获取权限表中所有权限 */ public void loadResourceDefine()&#123; map = new HashMap&lt;&gt;(); Collection&lt;ConfigAttribute&gt; array; ConfigAttribute cfg; List&lt;Permission&gt; permissions = usersMapper.findAllPermission(); for(Permission permission : permissions) &#123; array = new ArrayList&lt;&gt;(); cfg = new SecurityConfig(permission.getName()); //此处只添加了用户的名字，其实还可以添加更多权限的信息，例如请求方法到ConfigAttribute的集合中去。此处添加的信息将会作为MyAccessDecisionManager类的decide的第三个参数。 array.add(cfg); //用权限的getUrl() 作为map的key，用ConfigAttribute的集合作为 value， map.put(permission.getUrl(), array); &#125; &#125; //此方法是为了判定用户请求的url 是否在权限表中，如果在权限表中，则返回给 decide 方法，用来判定用户是否有此权限。如果不在权限表中则放行。 @Override public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException &#123; if(map ==null) loadResourceDefine(); //object 中包含用户请求的 url 信息 String url = ((FilterInvocation) object).getRequestUrl(); String resUrl; for(Iterator&lt;String&gt; iter = map.keySet().iterator(); iter.hasNext(); ) &#123; resUrl = iter.next(); if(resUrl .matches(url)) &#123; return map.get(resUrl); &#125; &#125; return null; &#125; @Override public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() &#123; return null; &#125; @Override public boolean supports(Class&lt;?&gt; clazz) &#123; return true; &#125;&#125; 实现 AccessDecisionManager (授权管理器)判断用户请求的资源是否能通过12345678910111213141516171819202122232425262728293031323334353637@Servicepublic class MyAccessDecisionManager implements AccessDecisionManager &#123; // decide 方法是判定是否拥有权限的决策方法， //authentication 是CustomUserService中循环添加到 GrantedAuthority 对象中的权限信息集合. //object 包含客户端发起的请求的requset信息，可转换为 HttpServletRequest request = ((FilterInvocation) object).getHttpRequest(); //configAttributes 为MyInvocationSecurityMetadataSource的getAttributes(Object object)这个方法返回的结果，此方法是为了判定用户请求的url 是否在权限表中，如果在权限表中，则返回给 decide 方法，用来判定用户是否有此权限。如果不在权限表中则放行。 @Override public void decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException, InsufficientAuthenticationException &#123; if(null== configAttributes || configAttributes.size() &lt;=0) &#123; return; &#125; ConfigAttribute c; String needRole; for(Iterator&lt;ConfigAttribute&gt; iter = configAttributes.iterator(); iter.hasNext(); ) &#123; c = iter.next(); needRole = c.getAttribute(); //authentication 为 CustomUserDetailService 中循环添加到 GrantedAuthority 对象中的权限信息集合 for(GrantedAuthority ga : authentication.getAuthorities()) &#123; if(needRole.trim().equals(ga.getAuthority())) &#123; return; &#125; &#125; &#125; throw new AccessDeniedException(\"no right\"); &#125; @Override public boolean supports(ConfigAttribute attribute) &#123; return true; &#125; @Override public boolean supports(Class&lt;?&gt; clazz) &#123; return true; &#125;&#125; 测试 踩坑加密方式WebSecurityConfig 配置文件认证规则方法”configure(AuthenticationManagerBuilder auth)” 报错java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id &quot;null&quot; 原因: spring security 版本在5.0后，之前版本中的 NoOpPasswordEncoder 被 DelegatingPasswordEncoder 取代了，而你保存在数据库中的密码没有指定加密方式,就要加个 PasswordEncoder 验证 认证管理器异常抛出CustomUserDetailService 类 loadUserByUsername 默认抛出 UsernameNotFoundException，用 DisabledException 替换 UsernameNotFoundException这里我们不抛出 UsernameNotFoundException 因为 Security 会把我们抛出的该异常捕捉并换掉，导致抛出的异常无法被 ControllerAdvice 捕捉到，无法进行统一异常处理；所以我们只需要打印正确的异常消息即可，Security 自动把异常添加到 HttpServletRequest 或 HttpSession 中 权限管理设置1.使用权限表设置，如上即权限管理流程图所示，通过实现 MyFilterSecurityInterceptor(资源管理拦截器)、MyAccessDecisionManager(授权管理器)和MySecurityMetadataSource(拦截器)进行权限拦截。 2.不通过权限表设置2.1 使用注解方式在 controller 和 WebSecurityConfig 上进行设置2.2 直接在 WebSecurityConfig 中 configure(HttpSecurity http) 方法进行设置 PS:hasRole() 方法默认含有 ‘ROLE_’ 前缀，书写方式：‘ROLE_ADMIN’ –&gt; hasRole(‘ADMIN’) 源码项目 github 源码：https://github.com/xeh1430/xehProject/tree/master/security","categories":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}],"tags":[],"keywords":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}]},{"title":"Spring Boot 使用 Spring Security (一)","slug":"20181227-springSecurity使用","date":"2018-12-27T02:26:04.000Z","updated":"2019-03-14T13:03:44.000Z","comments":true,"path":"text/springSecurity1.html","link":"","permalink":"http://yoursite.com/text/springSecurity1.html","excerpt":"","text":"Spring Security 介绍 Spring Security 是一个功能强大且可高度自定义的身份验证和访问控制框架。它是保护基于 Spring 的应用程序的事实上的标准。Spring Security 是一个专注于为 Java 应用程序提供身份验证和授权的框架。与所有 Spring 项目一样，Spring Security 的真正强大之处在于它可以轻松扩展以满足自定义要求。 Spring Security 特点 1.对身份验证和授权的全面和可扩展的支持2.防止会话固定，点击劫持，跨站点请求伪造等攻击3.Servlet API 集成4.可选与 Spring Web MVC 集成 在 Spring Boot 项目中添加 Spring Security创建 Spring Boot 已经在之前的博客中提到了，详情请查看 Spring Boot 入门 功能：创建静态页面，通过 Spring Security 权限管理，熟悉 Spring Security 的功能及配置 引入 maven 依赖Spring Security 依赖如下1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 创建静态页面创建三个静态页面：主页、hello 页面和登录页面注意：静态文件不要 WEB-INF 下，应用服务器把 WEB-INF 指为禁访目录，即直接在浏览器里是不能访问到的src/main/resources/templates/home.html 12345678910&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt; &lt;head&gt; &lt;title&gt;Spring Security Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;欢迎!&lt;/h1&gt; &lt;p&gt;点击 &lt;a th:href=\"@&#123;/hello&#125;\"&gt;这里&lt;/a&gt;进入 hello 页面.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 主页中，在 Thymeleaf 模板定义跳转到 hello 页面src/main/resources/templates/hello.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt; &lt;head&gt; &lt;title&gt;Hello World!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 th:inline=\"text\"&gt;Hello [[$&#123;#httpServletRequest.remoteUser&#125;]]!&lt;/h1&gt; &lt;form th:action=\"@&#123;/logout&#125;\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"Sign Out\"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 登录页面src/main/resources/templates/login.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt; &lt;head&gt; &lt;title&gt;Spring Security Example &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div th:if=\"$&#123;param.error&#125;\"&gt; Invalid username and password. &lt;/div&gt; &lt;div th:if=\"$&#123;param.logout&#125;\"&gt; You have been logged out. &lt;/div&gt; &lt;form th:action=\"@&#123;/login&#125;\" method=\"post\"&gt; &lt;div&gt;&lt;label&gt; User Name : &lt;input type=\"text\" name=\"username\"/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;label&gt; Password: &lt;input type=\"password\" name=\"password\"/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=\"submit\" value=\"Sign In\"/&gt;&lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 配置 Spring MVC 的配置类Web应用程序基于 Spring MVC,配置 Spring MVC 并设置视图控制器访问页面 src/main/java/hello/MvcConfig.java 12345678910111213141516171819202122232425package hello;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; /** * 配置预先配置了响应状态代码的简单自动控制器和/或视图以呈现响应主体。 * 覆盖 WebMvcConfigurer 中的 addViewControllers 同名方法 * 添加了四个视图控制器，前两个引用名称为 “home”（在其中定义 home.html）的视图， * 另一个引用名为 “hello”（在其中定义 hello.html）的视图， * 最后一个引用另一个名为 “login” 的视图 * @param registry */ public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/home\").setViewName(\"home\"); registry.addViewController(\"/\").setViewName(\"home\"); registry.addViewController(\"/hello\").setViewName(\"hello\"); registry.addViewController(\"/login\").setViewName(\"login\"); &#125;&#125; 设置Spring Securitysrc/main/java/hello/WebSecurityConfig.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package hello;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.provisioning.InMemoryUserDetailsManager;@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; /** * 该方法定义 url 的访问权限，登录路径，注销 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests() .antMatchers(\"/\", \"/home\").permitAll() //任何人(包括没有经过验证的)都可以访问 \"/\" 和 \"/home\" // .antMatchers(\"/admin/**\").hasRole(\"ADMIN\") // \"/admin/\" 开头的 URL 必须要是管理员用户，譬如 ”admin” 用户 .anyRequest().authenticated() //所有其他的 URL 都需要用户进行验证 .and() .formLogin() //使用 Java 配置默认值设置了基于表单的验证。使用 POST 提交到\"/login\"时，需要用 \"username\" 和 \"password\" 进行验证 .loginPage(\"/login\") //指定在需要登录时将用户发送到的URL .permitAll() //用户可以访问 formLogin() 相关的任何URL .and() .logout() //注销 .permitAll(); //用户可以访问 logout() 相关的任何URL。 &#125; /** * 配置创建一个 Servlet 过滤器，称为 springSecurityFilterChain 负责应用程序内的所有安全性 * （保护应用程序 URL，验证提交的用户名和密码，重定向到登录表单等） * @return */ @Bean @Override public UserDetailsService userDetailsService() &#123; UserDetails user = User.withDefaultPasswordEncoder() .username(\"user\") .password(\"password\") .roles(\"USER\") .build(); return new InMemoryUserDetailsManager(user); &#125;&#125; Spring Security 还有许多设置，想了解可以查看 WebSecurityConfig 更多常用设置；如需了解全部请查看官方文档 运行通过项目 main() 方法主入口启动项目,应用程序启动后，将浏览器指向 http://localhost:8080。你应该看到主页： 点击超链接,访问 hello 页面，因为刚才使用 Security 设置了权限，所以访问不到，直接跳转到登录页面 输入错误的用户名密码，请重新输入登录 登录成功，点击 Sign Out 按钮可注销登录 成功注销，回到登录页面 参考Spring 官方案例","categories":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}],"tags":[],"keywords":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}]},{"title":"Spring Boot 入门","slug":"20181217-springBoot入门","date":"2018-12-17T06:48:44.000Z","updated":"2019-03-14T13:03:32.000Z","comments":true,"path":"text/springBoot.html","link":"","permalink":"http://yoursite.com/text/springBoot.html","excerpt":"","text":"Spring Boot 介绍 Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 Spring Boot 特点简单、快速、方便 1.创建独立的 Spring 应用程序2.直接嵌入 Tomcat，Jetty 或 Undertow（无需部署 WAR 文件）3.提供固定的 “引用” 依赖项以简化构建配置4.尽可能自动配置 Spring 和第三方库5.提供生产就绪功能，例如指标，运行状况检查和外部化配置6.绝对没有代码生成，也不需要 XML 配置 快速入门创建 Spring Boot 有两个方式，通过访问 http://start.spring.io 获取 Spring Boot 基础项目，通过IDE创建 Spring Boot 项目。 通过 http://start.spring.io 下载 Spring Boot 基础项目1.访问 http://start.spring.io2.选择配置相关参数，如下图3.将下载的项目压缩包解压，导入IDE即可 通过 IDE 创建 Spring Boot 项目(以 idea 为例)打开idea，File -&gt; New -&gt; Project -&gt; 选择 Spring Initializr -&gt; Next -&gt; 设置包名项目名构建工具 Next -&gt; 添加依赖 Next -&gt; Finish打开项目，项目结构如下如上图所示，Spring Boot 的基础结构共三个文件: src/main/java 程序开发以及主程序入口 src/main/resources 配置文件 src/test/java 测试程序 至此，Spring Boot 项目创建成功。 创建一个简单的 Web 应用程序在 pom.xml 文件中添加 web 依赖包1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 创建 Web 控制器1234567891011121314package com.example.demo;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.bind.annotation.RequestMapping;@RestControllerpublic class HelloController &#123; @RequestMapping(\"/\") public String index() &#123; return \"Greetings from Spring Boot!\"; &#125; &#125; @RestController 让 Spring MVC 可以使用它来处理Web请求@RequestMapping(“/“) 映射/到 index() 方法。从浏览器调用或在命令行上使用curl时，该方法返回纯文本@RestController=@Controller+@ResponseBody，两个注释会导致Web请求返回数据而不是视图 在 Application 类中调用 controller12345678910111213141516171819202122232425262728293031package com.example.demo;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.Bean;import java.util.Arrays;@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @Bean public CommandLineRunner commandLineRunner(ApplicationContext ctx) &#123; return args -&gt; &#123; System.out.println(\"Let's inspect the beans provided by Spring Boot:\"); String[] beanNames = ctx.getBeanDefinitionNames(); Arrays.sort(beanNames); for (String beanName : beanNames) &#123; System.out.println(beanName); &#125; &#125;; &#125;&#125; @SpringBootApplication 是一个便利注解，包含了以下所有内容： @Configuration 标记该类作为应用程序上下文的bean定义的源。 @EnableAutoConfiguration 告诉 Spring Boot 开始根据类路径设置，其他 bean 和各种属性设置添加 bean。 @ComponentScan告诉 Spring 在包中寻找其他组件，配置和服务 hello，允许它找到控制器。main()方法使用 Spring Boot 的 SpringApplication.run() 方法来启动应用程序 运行项目控制台输出由 Spring Boot 提供的引导包访问http://localhost:8080/调用控制器页面显示： Greetings from Spring Boot!访问成功！ 单元测试添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 编写一个简单的单元测试，通过端点模拟 servlet 请求和响应1234567891011121314151617181920package com.example.demo;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoApplicationTests &#123; @Autowired private HelloController helloController; @Test public void getHello() throws Exception &#123; System.out.println(\"\\n\"+helloController.index()); &#125;&#125; 运行测试类，控制台成功输出即可。 学习资源Spring Boot 官网Spring Boot 官方入门案例","categories":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}],"tags":[],"keywords":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}]},{"title":"Web Service 调用天气预报","slug":"20181126-WebService调用天气预报","date":"2018-11-26T07:40:34.000Z","updated":"2019-03-14T13:03:28.000Z","comments":true,"path":"text/webService2.html","link":"","permalink":"http://yoursite.com/text/webService2.html","excerpt":"","text":"webservice 资源 免费 webservice 接口，包含天气预报、国内手机号码归属地查询WEB服务等多种服务http://www.webxml.com.cn/zh_cn/web_services.aspx本次项目使用天气预报的接口http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?wsdl创建 java 工程，将天气预报 wsdl 生成客户端代码，具体参考： Web Service 入门 生成代码问题解决直接使用 wsdl 调用生成代码会报错，无法生成。 修改 wsdl 文件里面的一个内容&lt;s:element ref=”s:schema”/&gt;&lt;s:any/&gt;替换为&lt;s:any minOccurs=”2” maxOccurs=”2”/&gt;注意要全部替换 调用天气预报接口成功生成代码之后，参考接口文档，编写客户端调用 天气预报接口列表http://ws.webxml.com.cn/WebServices/WeatherWS.asmx 客户端调用代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class TestWeather &#123; public static void main(String[] args) &#123; WeatherWS ws = new WeatherWS(); WeatherWSSoap soap = ws.getWeatherWSSoap(); /** * 获得天气预报数据 * 输入参数：城市/地区ID或名称 * 返回数据：一维字符串数组 */ ArrayOfString weather = soap.getWeather(\"广州\", null); List&lt;String&gt; list = weather.getString(); System.out.println(\"天气预报数据:\\n\"+list); System.out.println(); /** * 获得国外国家名称和与之对应的ID * 输入参数：无， * 返回数据：一维字符串数组 */ ArrayOfString country = soap.getRegionCountry(); List&lt;String&gt; list2 = country.getString(); System.out.println(\"国家名称对应数据:\\n\"+list2); System.out.println(); /** * 获得中国省份、直辖市、地区和与之对应的ID * 输入参数：无 * 返回数据：一维字符串数组 */ ArrayOfString province = soap.getRegionProvince(); List&lt;String&gt; list3 = province.getString(); System.out.println(\"省份地区对应数据:\\n\"+list3); System.out.println(); /** * 获得支持的城市/地区名称和与之对应的ID * 输入参数：theRegionCode = 省市、国家ID或名称 * 返回数据：一维字符串数组 */ ArrayOfString cityString = soap.getSupportCityString(\"广东\"); List&lt;String&gt; list4 = cityString.getString(); System.out.println(\"支持的城市/地区名称对应数据:\\n\"+list4); System.out.println(); &#125;&#125; 输出结果如下图","categories":[{"name":"Web Service","slug":"Web-Service","permalink":"http://yoursite.com/categories/Web-Service/"}],"tags":[],"keywords":[{"name":"Web Service","slug":"Web-Service","permalink":"http://yoursite.com/categories/Web-Service/"}]},{"title":"Web Service 入门","slug":"20181126-WebService入门","date":"2018-11-26T01:55:20.000Z","updated":"2019-03-14T13:03:24.000Z","comments":true,"path":"text/webService1.html","link":"","permalink":"http://yoursite.com/text/webService1.html","excerpt":"","text":"Web Service 简介Web Service 技术，能使得运行在不同机器上的不同应用无须借助附加的、专门的第三方软件或硬件，就可相互交换数据或集成。依据 Web Service 规范实施的应用之间，无论它们所使用的语言、平台或内部协议是什么，都可以相互交换数据。Web Service 是一种跨编程语言和跨操作系统平台的远程调用技术。 详细信息： WebService百度百科 WebService 的原理XML+XSD,SOAP 和 WSDL 就是构成 WebService 平台的三大技术SOAP 协议 = HTTP 协议 + XML 数据格式 WebService 开发可以分为服务器端开发和客户端开发两个方面对客户端而言，我们给这各类 WebService 客户端 API 传递 wsdl 文件的 url 地址，这些 API 就会创建出底层的代理类，我调用 这些代理，就可以访问到 webservice 服务。代理类把客户端的方法调用变成 soap 格式的请求数据再通过 HTTP 协议发出去，并把接收到的 soap 数据变成返回值返回。对服务端而言，各类 WebService 框架的本质就是一个大大的 Servlet，当远程调用客户端给它通过 http 协议发送过来 soap 格式的请求数据时，它分析这个数据，就知道要调用哪个 java 类的哪个方法，于是去查找或创建这个对象，并调用其方法，再把方法返回的结果包装成 soap 格式的数据，通过http响应消息回给客户端。 JAVA WebService 规范Java 中共有三种 WebService 规范，分别是 JAXM&amp;SAAJ、JAX-WS（JAX-RPC）、JAX-RS。 Web Service 服务端开发创建一个 WebService 实例，实现服务端发布，客户端获取信息的功能。使用 idea 创建 springboot 项目，配置 WebService 和 web 依赖12341.编写 WebService 接口方法public interface HelloWebService &#123; String sayHello(String name);&#125; 123456789102.实现接口，作为 webservice 提供服务类 @WebServicepublic class HelloWebServiceImpl implements HelloWebService &#123; @Override public String sayHello(String name) &#123; String said = name + \",Hello~~\"; System.out.println(said); return said; &#125;&#125; 12345678910111213141516173.发布服务@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); /* 在服务器端运行 WebServicePublish 类中的 main 方法，控制台打印出发布 webservice 成功！ 在浏览器中输入我们在 WebServicePublish 类中定义的 url?wsdl (注意一定要加 wsdl ),浏览器显示一个 xml 文档 那么我们这个 WebService 就发布成功了。 */ //定义 webService 的发布地址，提供给外界使用接口的地址 String url = \"http://localhost:8081/WebService\"; Endpoint.publish(url,new HelloWebServiceImpl()); System.out.println(\"发布 webService 成功！\"); &#125;&#125; 14.浏览器输入 `http://localhost:8081/WebService?wsdl` 测试服务是否发布成功 Web Service 客户端实现访问http://localhost:8081/WebService?wsdl，将文档下载保存为 wsdl 格式 idea 解析 wsdl 文件反向生成代码用 idea 新建一个 java 项目，导入 wsdl 文件 wsdl 文件右键点击–&gt; WebServices –&gt; Generate Java Code From Wsdl –&gt;选择解析规范 JAX-WS(idea自带) 123456789101112编写客户端public class HelloClient &#123; public static void main(String[] args) &#123; //创建服务视图，视图是从 wsdl 文件的 service 标签的 name 属性获取 HelloWebServiceImplService helloWebServiceImplService = new HelloWebServiceImplService(); //获取服务实现类，实现类从 wsdl 文件的 portType 的 name 属性获取 HelloWebServiceImpl helloWebService = helloWebServiceImplService.getPort(HelloWebServiceImpl.class); //获取查询方法，从 portType的operation 标签获取 String str = helloWebService.sayHello(\"小明\"); System.out.println(str); &#125;&#125; 直接执行，控制台成功输出","categories":[{"name":"Web Service","slug":"Web-Service","permalink":"http://yoursite.com/categories/Web-Service/"}],"tags":[],"keywords":[{"name":"Web Service","slug":"Web-Service","permalink":"http://yoursite.com/categories/Web-Service/"}]},{"title":"Axure 入门使用","slug":"20181112-Axure入门使用","date":"2018-11-12T14:26:50.000Z","updated":"2019-03-14T13:03:20.000Z","comments":true,"path":"text/axure.html","link":"","permalink":"http://yoursite.com/text/axure.html","excerpt":"","text":"Axure RP 是一款专业的快速原型设计工具。Axure RP 是美国 Axure Software Solution 公司旗舰产品，是一个专业的快速原型设计工具，让负责定义需求和规格、设计功能和界面的专家能够快速创建应用软件或 Web 网站的线框图、流程图、原型和规格说明文档。作为专业的原型设计工具，它能快速、高效的创建原型，同时支持多人协作设计和版本控制管理。 下载Axure RP 是收费软件，只有30天免费试用，可以到下面官网下载。Axure官网下载：https://www.axure.com/download 百度云资源下载链接：https://pan.baidu.com/s/1dLmf5aptMGjYQYiyozgpHg提取码：t30y 安装双击 AxureRP-setup.exe 进入安装提示页面，按 “下一步” 一直到完成安装。 打开软件，点击 “Enter License” 将 注册码.txt 中的激活码输入进去，或者进入 帮助-&gt;管理授权 输入激活码。 汉化(汉化包中附有步骤)1.关闭 Axure RP 软件，将 汉化包.rar 文件解压, 得到 lang 文件夹。2.将解压后的 lang 文件夹添加到软件的安装目录中。 使用资源提供《Axure RP 8 实战手册》pdf，可以根据内容进行练习。 在线资源Axure 官方中文网Axure RP 8 实战手册","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Spring Boot:Whitelabel Error Page 错误解决","slug":"20181102-springBoot-Whitelabel-Error-Page","date":"2018-11-11T16:00:00.000Z","updated":"2019-03-14T13:02:44.000Z","comments":true,"path":"text/springBoot-Error.html","link":"","permalink":"http://yoursite.com/text/springBoot-Error.html","excerpt":"","text":"使用 Spring Boot 构建一个简单的工程，访问报错，页面显示 Whitelabel Error Page 404，找了很久，路径没错，注解也没错，毫无头绪。最后只能求助于百度了，终于知道问题出在哪里了。原因：程序只加载启动类所在包及其子包下的内容。我不小心包启动类放在了 web 包下，导致 dao 其他包的代码加载不到。 解决方法：1.在 Application 类中加上@ComponentScan(basePackages = {&quot;com.example&quot;})多个之间用”,”分隔。2.将启动类放在正确位置。","categories":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}],"tags":[],"keywords":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}]},{"title":"Markdown 入门","slug":"20181102-markdown入门","date":"2018-11-02T09:29:07.000Z","updated":"2019-03-14T13:02:38.000Z","comments":true,"path":"text/markdown.html","link":"","permalink":"http://yoursite.com/text/markdown.html","excerpt":"Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown 的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。","text":"Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown 的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。 标题以#表示，一个#最大，共六级 123456# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 一级标题二级标题三级标题四级标题五级标题六级标题 列表无序列表用 - + * 任何一种都可以12345678#### 无序列表 - 足球 + 篮球 * 乒乓球#### 有序列表 1. 足球 2. 篮球 3. 乒乓球 无序列表 足球 篮球 乒乓球 有序列表 足球 篮球 乒乓球 引用只需要在文本前加入 &gt; 这种尖括号（大于号）即可引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; 1234&gt; &amp;gt; &gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 &gt;这是引用的内容 这是引用的内容 这是引用的内容 图片与链接图片为：![]()链接为：[]()12![图片](https://mouapp.com.Mou_128.png) [百度](www.baidu.com) 链接：百度 粗体、斜体与删除线1234**粗体** *斜体* ***加粗并倾斜*** ~~删除线~~ 粗体粗体斜体加粗并倾斜删除线 表格12345| Tables | Are | Cool | | ------------- |:-------------:| -----:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码框 两个 ` 把代码包含(单行代码)三个 ` 报代码包含(多行代码) System.out.println(&quot;Hello MarkDown!&quot;)1System.out.println(\"Hello MarkDown!\") 字体、字号与颜色1234567&lt;font face=\"黑体\"&gt;我是黑体字&lt;/font&gt;&lt;font face=\"微软雅黑\"&gt;我是微软雅黑&lt;/font&gt;&lt;font face=\"STCAIYUN\"&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=5 face=\"黑体\"&gt;color=#0099ff size=72 face=\"黑体\"&lt;/font&gt;Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3。&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;&lt;font color=gray size=72&gt;color=gray&lt;/font&gt; 我是黑体字我是微软雅黑我是华文彩云color=#0099ff size=5 face=”黑体”color=#00ffffcolor=gray 居中&lt;center&gt;居中显示&lt;center&gt; 居中显示 分割线分割线的语法只需要三个 * 号1234-------*** **** 参考：[1]: https://www.jianshu.com/p/1e402922ee32/","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Hexo 入门","slug":"20181016-Hexo入门","date":"2018-10-15T16:00:00.000Z","updated":"2019-03-14T12:59:24.000Z","comments":true,"path":"text/hello-world.html","link":"","permalink":"http://yoursite.com/text/hello-world.html","excerpt":"","text":"Hexo官网Hexo文档Hexo GitHub 快速开始新建文章12$ hexo new \"My New Post\"$ hexo n \"My New Post\" (简写) 更多信息: Writing 启动服务12$ hexo server$ hexo s (简写) 更多信息: Server 生成静态文件12$ hexo generate$ hexo g (简写) 更多信息: Generating 部署到远程站点12$ hexo deploy$ hexo d (简写) 更多信息: Deployment","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]}]}
{"meta":{"title":"xeh的学习笔记","subtitle":"将记录当成一种习惯","description":"路漫漫其修远兮！","author":"xeh","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"数据结构与算法(四)——队列","slug":"20190411-数据结构-队列","date":"2019-04-11T01:30:07.000Z","updated":"2019-04-11T03:28:20.826Z","comments":true,"path":"text/dataStructure4.html","link":"","permalink":"http://yoursite.com/text/dataStructure4.html","excerpt":"","text":"队列(Queue)：具有先进先出的特性，支持在队尾插入元素，在队头删除元素的特性。 队列是一种操作受限的线性表数据结构，包含两个操作，入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。 用数组实现的队列，我们叫作顺序队列，用链表实现的队列，我们叫作链式队列。 队列的数组实现12345678910111213141516171819202122232425262728293031323334353637383940// 用数组实现的队列public class ArrayQueue &#123; // 数组：items，数组大小：n private String[] items; private int n = 0; // head 表示队头下标，tail 表示队尾下标 private int head = 0; private int tail = 0; // 申请一个大小为 capacity 的数组 public ArrayQueue(int capacity) &#123; items = new String[capacity]; n = capacity; &#125; // 入队操作，将 item 放入队尾 public boolean enqueue(String item) &#123; // tail == n 表示队列末尾没有空间了 if (tail == n) &#123; // tail ==n &amp;&amp; head==0，表示整个队列都占满了 if (head == 0) return false; // 数据搬移 for (int i = head; i &lt; tail; ++i) &#123; items[i-head] = items[i]; &#125; // 搬移完之后重新更新 head 和 tail tail -= head; head = 0; &#125; items[tail] = item; ++tail; return true; &#125; // 出队 public String dequeue() &#123; // 如果 head == tail 表示队列为空 if (head == tail) return null; String ret = items[head]; ++head; return ret; &#125;&#125; 队列的链表实现1234567891011121314151617181920212223242526272829303132public class LinkedQueue &#123; private Node head = null; private Node tail = null; private static class Node &#123; int value; Node next; public Node(int value) &#123; this.value = value; this.next = null; &#125; &#125; public boolean enqueue(int value) &#123; Node newNode = new Node(value); if (head == null) &#123; head = newNode; tail = newNode; &#125; else &#123; tail.next = newNode; tail = newNode; &#125; return true; &#125; public int dequeue() &#123; if (head == null) &#123; return -1; &#125; Node node = head.next; int value = node.value; head = node; return value; &#125;&#125; 循环队列具有队头指针和队尾指针，指示队列元素所在的位置，避免删除元素时移动大量元素。 123456789101112131415161718192021222324252627public class CircularQueue &#123; // 数组：items，数组大小：n private String[] items; private int n = 0; // head 表示队头下标，tail 表示队尾下标 private int head = 0; private int tail = 0; // 申请一个大小为 capacity 的数组 public CircularQueue(int capacity) &#123; items = new String[capacity]; n = capacity; &#125; // 入队 public boolean enqueue(String item) &#123; // 队列满了 if ((tail + 1) % n == head) return false; items[tail] = item; tail = (tail + 1) % n; return true; // 出队 // 如果 head == tail 表示队列为空 if (head == tail) return null; String ret = items[head]; head = (head + 1) % n; return ret; &#125;&#125; 阻塞队列阻塞队列其实就是在队列基础上增加了阻塞操作。在队列为空的时候，从队头取数据会被阻塞；队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。 生产者 - 消费者模型当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。 并发队列线程安全的队列我们叫作并发队列。 直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。 问题线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？两种处理策略;第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理 队列两种实现方式对于排队请求有什么区别呢？基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。 而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。 对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构与算法(三)——栈","slug":"20190410-数据结构-栈","date":"2019-04-10T13:29:07.000Z","updated":"2019-04-11T02:11:12.389Z","comments":true,"path":"text/dataStructure3.html","link":"","permalink":"http://yoursite.com/text/dataStructure3.html","excerpt":"","text":"栈(Stack)：当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性。 栈是一种操作受限的线性表数据结构，包含两个操作，入栈 push()和出栈 pop()，也就是在栈顶插入一个数据和从栈顶删除一个数据。 用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。 栈的数组实现123456789101112131415161718192021222324252627282930// 基于数组实现的顺序栈public class ArrayStack &#123; private String[] items; // 数组 private int count; // 栈中元素个数 private int n; // 栈的大小 // 初始化数组，申请一个大小为 n 的数组空间 public ArrayStack(int n) &#123; this.items = new String[n]; this.n = n; this.count = 0; &#125; // 入栈操作 public boolean push(String item) &#123; // 数组空间不够了，直接返回 false，入栈失败。 if (count == n) return false; // 将 item 放到下标为 count 的位置，并且 count 加一 items[count] = item; ++count; return true; &#125; // 出栈操作 public String pop() &#123; // 栈为空，则直接返回 null if (count == 0) return null; // 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一 String tmp = items[count-1]; --count; return tmp; &#125;&#125; 栈的链表实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class StackOfLinked&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; //定义一个内部类，就可以直接使用类型参数 private class Node&#123; Item item; Node next; &#125; private Node first; private int N; //构造器 public StackOfLinked()&#123;&#125; //添加 public void push(Item item)&#123; Node oldfirst = first; first = new Node(); first.item = item; first.next = oldfirst; N++; &#125; //删除 public Item pop()&#123; Item item = first.item; first = first.next; N--; return item; &#125; //是否为空 public boolean isEmpty()&#123; return N == 0; &#125; //元素数量 public int size()&#123; return N; &#125; //返回栈中最近添加的元素而不删除它 public Item peek()&#123; return first.item; &#125; public Iterator&lt;Item&gt; iterator() &#123; return new LinkedIterator(); &#125; //内部类：迭代器 class LinkedIterator implements Iterator&#123; int i = N; Node t = first; public boolean hasNext() &#123; return i &gt; 0; &#125; public Item next() &#123; Item item = (Item) t.item; t = t.next; i--; return item; &#125; &#125;&#125; 应用场景函数调用栈操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈 栈在表达式求值中的应用如：34+13*9+44-12/3两个栈对象，一个存操作数，一个存计算符，遇到运算符，就与运算符栈的栈顶元素进行比较，若比运算符栈顶元素优先级高，就将当前运算符压入栈，若比运算符栈顶元素的优先级低或者相同，从运算符栈中取出栈顶运算符，从操作数栈顶取出2个操作数，然后进行计算，把计算完的结果压入操作数栈，继续比较 栈在括号匹配中的应用如：{}{()}用栈保存为匹配的左括号，从左到右一次扫描字符串，当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号，如果能匹配上，则继续扫描剩下的字符串。如果扫描过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。 当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明未匹配的左括号为非法格式 实现浏览器的前进后退功能使用两个栈X和Y，我们把首次浏览的页面依次压如栈X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据一次放入Y栈。当点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，说明没有页面可以继续后退浏览了。当Y栈没有数据，那就说明没有页面可以点击前进浏览了","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"“耐性”不要太好","slug":"20190317-“耐性”不要太好","date":"2019-03-17T14:47:09.000Z","updated":"2019-03-17T15:35:29.008Z","comments":true,"path":"text/feeling.html","link":"","permalink":"http://yoursite.com/text/feeling.html","excerpt":"","text":"前几天玩微信，发现了“浮窗”这个小功能，刚好解决了一个我很不爽的问题。 我看公众号文章比较多，经常有人发信息给我而我正在看公众号文章，那我就不得不退出去回复信息再点回来继续看，但这来回看文章又要好多个步骤，很麻烦，也很厌烦。“浮窗”功能是将公众号文章缩小成为浮窗，显示在界面上，然后我们可以任意切换其它的微信界面，点击浮窗直接查看文章，刚好解决了我的问题。具体的操作说明在这里就不说了。 可能我“耐性”真的好，硬是忍了这么久。要不是前几天无意间发现“浮窗”这个功能，我都不知道会持续到什么时候。 刚发现时还以为是新上线的功能呢，兴冲冲地跑去查了一下，结果这个功能去年5月份上线的，将近一年时间了。此时我才真正的反思自己。 功能上线快一年，还可以解释为对产品功能不关注，但我已经明显用得不爽了，却一直忍受着，为什么不去寻找解决方法呢？真的是“耐性”好吗？不是的，我觉察到了，但根本没有意识到要去改变它，这是一个非常不好的状况。警醒！ 作为一个程序员，追求「极客精神」，这篇文章作为自己的一个警醒，努力变得更好！","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[],"keywords":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}]},{"title":"生活急救常识","slug":"20190314-生活急救常识","date":"2019-03-14T14:47:09.000Z","updated":"2019-03-16T11:06:23.361Z","comments":true,"path":"text/firstAid.html","link":"","permalink":"http://yoursite.com/text/firstAid.html","excerpt":"","text":"上周末，公司组织了一次关于生活急救常识的培训，收获很大，觉得有必要记录下来，牢牢掌握。 烧伤急救 烧伤：因接触热、电或化学物质引起的创伤。烧伤分类：热源、雷电、热液体、化学品、电流。 开水烫伤1.用大量的流水（注意水流，不要过大）持续冲洗降温，持续大约20分钟左右，让患处温度与周边正常皮肤温度一致。2.局部轻度红肿或出现少量水泡（轻度烫伤），可在冲泡后，用烫伤药均匀涂抹，之后用无菌纱布或干净的纯棉毛巾覆盖于伤口并固定；3.严重的紧急处理后赶快就医。 忌冰敷：不可以直接冰敷，以免冻伤。用酱油涂：伤口上撒盐，会加重伤逝。牙膏涂抹：牙膏会使皮肤热气无处散发。用白酒冲洗伤口：皮肤未破溃时有一定降温效果；皮肤已破溃会加重疼痛，加深创面。 明火烧伤若衣服着火，卧倒在地滚压灭火，或用水浇灭火焰。 烧伤急救五字要诀，“冲、脱、泡、包、送” 冲：用清水冲洗烧伤创面；脱：边冲边用轻柔的动作脱掉烧伤者的外衣，如果衣服粘住皮肉，不能强扯，可以用剪刀剪开；泡：用冷水浸泡创面；包：用干净的布单、衣物包扎伤处，有纱布最好；送：尽快送到具有救治烧伤经验的医院治疗。 当然就医一般看烧伤情况。 电击烧伤1.先将电源切断，或用绝缘体将电源移开，如干木棒、树枝、扫帚柄等。电源不明时，切记不要直接用手接触触电者。2.在浴室或潮湿的地方，救护人要穿绝缘胶鞋戴胶皮手套或站在干燥木板上以保护自身安全。3.如伤员无心跳、呼吸，拨打120呼叫救护车，并立即施行心肺复苏术，不要轻易放弃，一直坚持到医生护士到来为止。4.局部烧伤病人应马上降温，然后就地取材进行创面的简易包扎，再送医院救治。 窒息急救 窒息：是指异物卡在咽喉部位气道处导致出现窒息的状况。分为轻度异物堵塞和重度异物堵塞。 鱼刺卡喉吃鱼难免会遇到鱼刺卡到喉咙，所以正确处理很重要。鱼刺如上图所示，一个三叉形状，一般鱼刺卡喉都是因为鱼刺倒叉在喉咙上。 生活中很多处理方法都是错误的，如大口吞饭、大口喝水、大口喝醋，这些方法只会让鱼刺扎得越深，即使解决问题也会让食道受伤。 正确方式：轻微的咳嗽出来就好，再者张开嘴让亲友夹出来，严重得请及时到医院就医 轻度异物堵塞可以说话或发出声音、可以大声咳嗽。咳嗽将异物咳出就好。 重度度异物堵塞无法呼吸、说话或者发出声音、有窒息的感觉。立即采取急救方法处理。 海姆立克急救法（腹部冲击法）:急救者首先以前腿弓，后腿登的姿势站稳，然后使患者坐在自己弓起的大腿上，并让其身体略前倾。然后将双臂分别从患者两腋下前伸并环抱患者。左手握拳，右手从前方握住左手手腕，使左拳虎口贴在患者胸部下方，肚脐上方的上腹部中央，形成“合围”之势，然后突然用力收紧双臂，用左拳虎口向患者上腹部内上方猛烈施压，迫使其上腹部下陷。这样由于腹部下陷，腹腔内容上移，迫使膈肌上升而挤压肺及支气管，这样每次冲击可以为气道提供一定的气量，从而将异物从气管内冲出。施压完毕后立即放松手臂，然后再重复操作，直到异物被排出。 动物咬伤猫狗咬伤清理伤口伤口不大，用肥皂水和清水交替清洗伤口 15 分钟，用碘伏和酒精消毒，不要包扎；咬伤严重，那就赶快直接送医院。 判断是否要注射疫苗1.如果被不知哪来的流浪猫狗咬伤、抓伤，是百分百要注射疫苗的。2.如果是被宠物猫狗咬伤、抓伤，就要具体看了。 怎么判断咬你的猫猫狗狗有没有狂犬病呢？「十日观察法」猫狗只有感染了病毒，在发病前几天才有传染性，而狂犬病病毒凶猛，一旦发病，短则三五日，长则十日，这个猫狗也是要口吐白沫而死的。被猫狗咬伤，如果 10 天之后，这只猫或者狗安然无恙，那么基本可以判定，猫狗是健康的，自己没有感染狂犬病毒。 狂犬病 狂犬病病毒是一种嗜神经病毒，并不是通过血液传染，只要皮肤破损，就能感染。病毒沿着人的外周神经直捣中枢神经系统，引发神经病变。狂犬病的发病很快，死亡率几乎百分百，一旦发病，没得治，3～5 天就会死亡。 狂犬病的潜伏期并不长，通常是 1～3 个月，最短的不到 1 周，极少数会超过 1 年，而不是传闻中的 20 年。没被咬出血，也会感染狂犬病病毒；现阶段狂犬病没法治，只能注射疫苗；不仅猫和狗会携带狂犬病病毒，很多家畜和野生动物都会携带。 蜜蜂蜇伤1.刮掉毒刺、毒囊；2.用大量肥皂水冲洗伤口；3.因为体质问题，有些人会出现呼吸困难、伤口红肿、呕吐或腹泻等症状，请立即去医院就医。 流鼻血流鼻血一般是鼻粘膜或毛细血管破裂导致。 错误方法：仰头，塞纸巾在鼻孔里。 正确方式：低头前倾，压按鼻翼止血。 心肺复苏术心搏骤停一旦发生，如得不到即刻及时地抢救复苏，4～6min后会造成患者脑和其他人体重要器官组织的不可逆的损害，因此心搏骤停后的心肺复苏（cardiopulmonary resuscitation, CPR）必须在现场立即进行。 胸外心脏按压按压位置：胸骨中、下1/3交界处的正中线上或剑突上2.5～5cm处（一般是两乳头连线中间处）；手掌根部紧放在按压部位，两手平行重叠且手指交叉互握抬起，使手指脱离胸壁。 按过模型，这是个体力活，真的累！ 好人法 《中华人民共和国民法总则》第184条于2017年3月15日，第十二届全国人民代表大会第五次会议通过。规定：“因自愿实施紧急救助行为造成受助人损害的，救助人不承担民事责任。” 好人法，善意救助者责任豁免！","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[],"keywords":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}]},{"title":"数据结构与算法(二)——数组、链表","slug":"20190221-数据结构-数组-链表","date":"2019-02-21T09:29:07.000Z","updated":"2019-03-14T13:03:14.399Z","comments":true,"path":"text/dataStructure2.html","link":"","permalink":"http://yoursite.com/text/dataStructure2.html","excerpt":"","text":"常用数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Tire树(字典树)线性表结构：数组、链表、栈、队列、散列表非线性表：二叉树、堆、图、树 线性表（Linear List）是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向。非线性表，数据之间并不是简单的前后关系。 数据结构的特性 数组 数组是一种线性表数据结构；它用一组连续的内存空间，来存储一组具有相同类型的数据。连续的内存空间、相同的数据类型，所以数组可以随机访问，但对数组进行删除插入，为了保证数组的连续性，就要做大量的数据搬移工作。数组都是从 0 开始编号的，从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。 数组适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好的数组，用二分查找，时间复杂度也是O（logn）。数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。 优点：简单易用，查找快缺点：大小固定，增删慢 数组如何实现下标随机访问？例：长度为 10 的 int 类型的数组 int[] a = newint[10]，计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address =1000。计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：$$a[i]_address = base_address + i * data_type_size$$data_type_size 表示数组中每个元素的大小。 容器的优劣相比于数组，java 中的 ArrayList 将很多数组操作的细节封装起来，并支持动态扩容。一旦超过存储容量，扩容时比较耗内存，因为涉及到内存申请和数据搬移。 数组适合的场景1.Java ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别关注性能，可以考虑数组2.若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组。3.表示多维数组时，数组往往更加直观。4.业务开发容器即可，底层开发，如网络框架，性能优化。选择数组。 链表 从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。链表通过指针将一组零散的内存块串联在一起，内存块称为链表的“结点”(Node 存储数据、记录链上的下一个结点的地址),后继指针(next)用来记录下个结点地址的指针。 优点：增删快 O(1)，支持动态扩容缺点：查找慢 O(n)，内存空间消耗大，频繁增删，容易造成冗余 三种最常见的链表结构：单链表、双向链表和循环链表 单链表每个节点只包含一个指针，即后继指针。单链表有两个特殊的节点，即头节点和尾节点。头结点用来记录链表的基地址，尾结点指向一个空地址 NULL，表示这是链表上最后一个结点。 循环链表除了尾节点的后继指针指向首节点的地址外均与单链表一致。适用于存储有循环特点的数据，比如约瑟夫问题。 双向链表节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针 prev）和下一个节点地址（后继指针 next），首节点的前驱指针 prev 和尾节点的后继指针均指向空地址 双向循环链表首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点 比较 时间复杂度 数组 链表 随机访问 $$O(1)$$ $$O(n)$$ 插入删除 $$O(n)$$ $$O(1)$$ 应用LRU 缓存策略 缓存是一种提高数据读取性能的技术。缓存的大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？就需要用到缓存淘汰策略。缓存淘汰策略是当缓存被用满时清理数据的优先顺序。 常见的三种缓存淘汰策略先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frenquently Used）、最近最少使用策略 LRU（Least Recently Used）。 链表实现 LRU当访问的数据没有存储在缓存的链表中时，直接将数据插入链表表头，时间复杂度为O(1)；当访问的数据存在于存储的链表中时，将该数据对应的节点，插入到链表表头,时间复杂度为O(n)。如果缓存被占满，则从链表尾部的数据开始清理，时间复杂度为O(1)。 PS:维护一个有序链表，尾部为最早访问的数据，头部为最新，现插入一数据1.遍历，查看数据是否存在2.1 存在，删除已有数据，将数据插入到头部2.2 不存在2.2.1 链表没满，直接插入到头部2.2.2 链表满了，删除链表尾节点，将数据插入头部 数组实现 LRU1.首位置保存最新访问数据，末尾位置优先清理当访问的数据未存在于缓存的数组中时，直接将数据插入数组第一个元素位置，此时数组所有元素需要向后移动1个位置，时间复杂度为O(n)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉末尾的数据，时间复杂度为O(1)。 2.首位置优先清理，末尾位置保存最新访问数据当访问的数据未存在于缓存的数组中时，直接将数据添加进数组作为当前最有一个元素时间复杂度为O(1)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入当前数组最后一个元素的位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉数组首位置的元素，且剩余数组元素需整体前移一位，时间复杂度为O(n)。（优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。） 链表回文串验证使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if (head == null || head.next == null) &#123; return true; &#125; ListNode prev = null; ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; ListNode next = slow.next; slow.next = prev; prev = slow; slow = next; &#125; if (fast != null) &#123; slow = slow.next; &#125; while (slow != null) &#123; if (slow.val != prev.val) &#123; return false; &#125; slow = slow.next; prev = prev.next; &#125; return true; &#125;&#125; 时空替换思想时空替换思想：“用空间换时间” 与 “用时间换空间”当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高，时间复杂度小相对较低的算法和数据结构，缓存就是空间换时间的例子。如果内存比较紧缺，比如代码跑在手机或者单片机上，这时，就要反过来用时间换空间的思路。 「空间换时间」某些情况下”双向链表”替代”单向链表”；缓存","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"数据结构与算法(一)——复杂度分析","slug":"20190220-数据结构-复杂度分析","date":"2019-02-20T09:29:07.000Z","updated":"2019-03-14T13:03:08.927Z","comments":true,"path":"text/dataStructure1.html","link":"","permalink":"http://yoursite.com/text/dataStructure1.html","excerpt":"","text":"介绍 数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。数据结构是为算法服务的，算法要作用在特定的数据结构之上。 数据结构与算法中最重要的概念：复杂度分析最常用、最基础的 20 个数据结构与算法：数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Tire树(字典树)算法： 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法 复杂度分析复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。复杂度分析表示效率和资源消耗的度量衡。 为什么要进行复杂度分析1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。 复杂度分析法则1.单段代码看高频：比如循环。2.多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。3.嵌套代码求乘积：比如递归、多重循环等4.多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。 大 O 复杂度表示法算法的执行时间 T(n) 与每行代码的执行次数 n 成正比$$T(n) = O( f(n) )$$ T(n)：代码执行的时间； n：表示数据规模的大小； f(n)：表示每行代码执行的次数总和 12345678int cal(int n) &#123; int sum = 0; // 1 int i = 1; // 1 for (; i &lt;= n; ++i) &#123; // n sum = sum + i; // n &#125; return sum;&#125; $$时间复杂度为：T(n) = O(2n+2)$$ 当 n 很大时，公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。 $$T(n) = O(2n+2) -&gt; T(n) =O(n)$$ 时间复杂度大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。 判断依据只关注循环执行次数最多的一段加法法则：总复杂度等于量级最大的那段代码的复杂度乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的积 复杂度量级 常量阶 $$O(1)$$ 指数阶 $$O(2^n)$$ 对数阶 $$O(logn)$$ 阶乘阶 $$O(n!)$$ 线性阶 $$O(n)$$ 线性对数阶 $$O(nlogn)$$ 平方阶 $$O(n^2)$$ 立方阶 $$O(n^3)$$ k次方阶 $$O(n^k)$$ 非多项式量级: O(2^n)和 O(n!) 时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。 当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。复杂度分析的4个概念1.最好情况时间复杂度（best case time complexity）：代码在最理想情况下执行的时间复杂度 O(1)。2.最坏情况时间复杂度（worst case time complexity）：代码在最坏情况下执行的时间复杂度 O(n)。3.平均情况时间复杂度（average case time complexity）：代码在所有情况下执行的次数的加权平均值表示，代码在不同情况下复杂度出现量级差别时使用。4.均摊时间复杂度（amortized time complexity）：代码在大部分情况下时间复杂度都很低，个别情况下时间复杂度比较高，操作之间存在前后连贯的时序关系，将较高时间复杂度的耗时，平摊到时间复杂度比较低的操作上。基本上均摊结果就等于低级别复杂度 O(1)。(使用摊还分析法计算) 为什么要引入这4个概念？1.同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。2.代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。 空间复杂度空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。空间复杂度是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。复杂度判断与时间复杂度类似，一般复杂度量级为：O(1)、O(n)、O(n^2)。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/数据结构/"}]},{"title":"知识的诅咒","slug":"20190215-知识的诅咒","date":"2019-02-15T01:47:53.000Z","updated":"2019-03-14T13:02:58.967Z","comments":true,"path":"text/knowledgeCurse.html","link":"","permalink":"http://yoursite.com/text/knowledgeCurse.html","excerpt":"","text":"什么是知识的诅咒 维基百科：一种认知偏差，当个体与其他个体交流时，他们会在不知不觉中假设其他人有理解的背景。 我们一旦知道了某事，就无法想象这件事在未知者眼中的样子。当我们把自己知道的知识解释给别人的时候，因为信息的不对等，我们很难把自己知道的完完全全给对方解释清楚。总之，我们的知识“诅咒”了我们。我们所认为的常识，可能就是别人的信息盲点。（信息不对称，既是商机也可能是一种沟通障碍） 表现形式学计算机的难以理解连百度都不会用的人如何生活。在我们享受 4G 时，如何体会尚未上过网的 5 亿中国人如何思考（《中国互联网络发展状况统计报告》统计显示，截至 2018年6月，中国网民规模为8.02亿，中国人口 13.9 亿，差额 5 亿多人） 当你知道某个知识，你就很难明白不知道这个知识的人到底是什么状态。或者你学会了某个技能你也完全忘了没会前是什么样子，好像从一开始就会一样。如果你不会一个东西，你往往会认为，会的人好厉害。 如何打破1. 扩大自己的圈子了解不同行业的人是如何在不同层面思考问题，缩小认知偏差。 2. 简化概念简单直白的话更易于理解。在给非专业较低水平的人交流时，不要长篇大论，也不应该过于深入的解读，我们要做的是让他们了解，而不是理解。 3. 用场景代替抽象名词善用比喻和故事，让听的人自己在场景中感受，而不是强加我们的理解认识给他们。 看见差异，尊重差异","categories":[{"name":"阅读","slug":"阅读","permalink":"http://yoursite.com/categories/阅读/"}],"tags":[],"keywords":[{"name":"阅读","slug":"阅读","permalink":"http://yoursite.com/categories/阅读/"}]},{"title":"Spring Boot 使用 Spring Security (二)","slug":"20190130-springSecurity权限校验","date":"2019-01-30T12:38:46.000Z","updated":"2019-03-14T13:02:50.713Z","comments":true,"path":"text/springSecurity2.html","link":"","permalink":"http://yoursite.com/text/springSecurity2.html","excerpt":"","text":"介绍 使用 springboot+mybatis＋SpringSecurity 实现数据库动态的管理用户、角色、权限管理。 细分角色和权限，并将用户、角色、权限和资源均采用数据库存储，并且自定义滤器，代替原有的FilterSecurityInterceptor过滤器，并分别实现 AccessDecisionManager、InvocationSecurityMetadataSourceService 和 serDetailsService，并在配置文件中进行相应配置。 数据库表设计12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#创建用户表create table user( id int not null primary key comment'主键id', username varchar(50) not null comment'用户名', password varchar(50) not null comment'密码')#角色表create table role( id int not null primary key comment'主键id', name varchar(50) not null comment'角色名')#用户角色表create table user_role( user_id varchar(50) not null comment'用户id', role_id varchar(50) not null comment'角色id')#权限表create table permission ( id int unsigned not null auto_increment comment'主键id', name varchar (200) not null comment'角色名', description varchar (200) default null comment'描述', url varchar (200) not null comment'路径', pid int default null comment'上级id', primary key (id))#角色权限中间表create table permission_role ( id int unsigned not null auto_increment comment'主键id', role_id int unsigned not null comment'角色id', permission_id int unsigned not null comment'权限id', primary key (id))#插入用户INSERT INTO user(id,username,password)VALUES('1',admin','admin');INSERT INTO user(id,username,password)VALUES('2',user','user');INSERT INTO user(id,username,password)VALUES('3',test','test');#插入角色INSERT INTO role VALUES ('1', 'ROLE_ADMIN'); INSERT INTO role VALUES ('2', 'ROLE_USER'); INSERT INTO user_role VALUES ('1', '1'); INSERT INTO user_role VALUES ('1', '2'); INSERT INTO user_role VALUES ('2', '2'); INSERT INTO permission VALUES ('1', 'ROLE_USER', 'user', '/admin/home', null);INSERT INTO permission_role VALUES ('1', '2', '1')); 项目结构 引入 maven 依赖pom 文件123456789101112131415161718192021222324252627282930313233343536373839404142&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql版本根据自身情况调整--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--thymeleaf页面展示控制--&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity4&lt;/artifactId&gt; &lt;version&gt;3.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置数据库信息123456789spring.datasource.url=jdbc:mysql://localhost:3306/worldspring.datasource.username=rootspring.datasource.password=123456spring.jpa.database=mysqlspring.datasource.driver-class-name=com.mysql.jdbc.Driverserver.port=8088 mybatis.mapper-locations=classpath:UserMapper.xml 创建 pojo/dao/mapper/controller 文件PS: 功能比较简单，所以省略 service 文件，直接调用 dao 层文件；并将权限表的相关查询操作写在同一 mapper 文件 User.java12345678public class User &#123; private int id; private String username; private String password; private List&lt;Role&gt; roles; /* Getter 和 Setter 自行补充 */&#125; Role.java123456public class Role &#123; private int id; private String name; /* Getter 和 Setter 自行补充 */&#125; Permission.java12345678910111213public class Role &#123; private int id; //权限名称 private String name; //权限描述 private String descritpion; //授权链接 private String url; //父节点id private int pid; /* Getter 和 Setter 自行补充 */&#125; UserMapper.java 12345678910@Mapper@Repositorypublic interface UserMapper &#123; //根据用户名查找用户所有权限信息 User findByUserName(String username); //获取所有权限信息 List&lt;Permission&gt; findAllPermission(); // List&lt;Permission&gt; findByAdminUserId(int userId);&#125; UserMapper.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.xeh.security.dao.UserMapper\"&gt; &lt;resultMap id=\"userMap\" type=\"com.xeh.security.model.User\"&gt; &lt;id property=\"id\" column=\"ID\"/&gt; &lt;result property=\"username\" column=\"username\"/&gt; &lt;result property=\"password\" column=\"PASSWORD\"/&gt; &lt;collection property=\"roles\" ofType=\"com.xeh.security.model.Role\"&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findByUserName\" parameterType=\"String\" resultMap=\"userMap\"&gt; select u.* ,r.name from user u LEFT JOIN user_role sru on u.id = sru.user_id LEFT JOIN role r on sru.role_id = r.id where username = #&#123;username&#125; &lt;/select&gt; &lt;select id=\"findAllPermission\" resultType=\"com.xeh.security.model.Permission\"&gt; select * from permission &lt;/select&gt; &lt;select id=\"findByAdminUserId\" parameterType=\"int\" resultType=\"com.xeh.security.model.Permission\"&gt; select p.* from user u left join user_role sru on u.id = sru.user_id left join role r on sru.role_id = r.id left join permission_role spr on spr.role_id = r.id left join permission p on p.id = spr.permission_id where u.id = #&#123;userId&#125; &lt;/select&gt;&lt;/mapper&gt; HelloController.java1234567891011121314151617@Controllerpublic class HelloController &#123; @RequestMapping(\"/admin/hello\") public String index()&#123; return \"hello\"; &#125; @RequestMapping(value =&#123;\"\",\"/\",\"/home\"&#125;) public String home()&#123; return \"home\"; &#125; @RequestMapping(\"/login\") public String login()&#123; return \"login\"; &#125;&#125; 页面文件home.html1234567891011&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt;&lt;head&gt; &lt;title&gt;Spring Security Home&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;欢迎!&lt;/h1&gt;&lt;p&gt;点击 &lt;a th:href=\"@&#123;/admin/hello&#125;\"&gt;这里&lt;/a&gt;进入hello页面.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; hello.html123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt;&lt;head&gt; &lt;title&gt;Hello World!&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:inline=\"text\"&gt;Hello [[$&#123;#httpServletRequest.remoteUser&#125;]]!&lt;/h1&gt;&lt;div sec:authorize=\"isAuthenticated()\"&gt; &lt;!-- 用户认证通过才能才显示 --&gt; &lt;p&gt;用户名:&lt;span sec:authentication=\"name\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;权限:&lt;span sec:authentication=\"principal.authorities\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;div sec:authorize=\"hasRole('ADMIN')\"&gt; &lt;!-- 用户角色为“ADMIN”才显示 --&gt; &lt;p&gt;【管理员】才能看见的内容&lt;/p&gt;&lt;/div&gt;&lt;div sec:authorize=\"hasRole('USER')\"&gt; &lt;!-- 用户角色具有“USER”权限才显示 --&gt; &lt;p&gt;【普通用户】才能看到的内容&lt;/p&gt;&lt;/div&gt;&lt;form th:action=\"@&#123;/logout&#125;\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"注销\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; login.html12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:if=\"$&#123;param.error&#125;\"&gt; 用户名或密码错误&lt;/div&gt;&lt;div th:if=\"$&#123;param.logout&#125;\"&gt; 账户已退出登录&lt;/div&gt;&lt;form th:action=\"@&#123;/login&#125;\" method=\"post\" action=\"/login\"&gt; &lt;div&gt;&lt;label&gt; 用户名: &lt;input type=\"text\" name=\"username\"/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;label&gt; 密 码: &lt;input type=\"password\" name=\"password\"/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=\"submit\" value=\"登录\"/&gt;&lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 这样，我们就搭好了连接数据库的 springboot 项目，接下来就是添加权限了 流程图SpringSecurity 登录认证流程图 SpringSecurity 权限管理流程图 添加 SpringSecurity,实现登录及权限验证创建 Spring Security 的配置类 WebSecurityConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Configuration@EnableWebSecurity //使得Spring Security提供并且支持了Spring MVC的集成public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; //用户无权限拦截处理类 @Autowired private MyAccessDeniedHandler accessDeniedHandler; //授权管理 @Autowired private MyFilterSecurityInterceptor myFilterSecurityInterceptor; //注册UserDetailsService 的bean，通过用户名加载与该用户的用户名、密码以及权限相关的信息 @Bean UserDetailsService customUserService()&#123; //注册UserDetailsService 的bean return new CustomUserDetailService(); &#125; /*定义认证规则*/ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(customUserService()).passwordEncoder(new MyPasswordEncoder()); //user Details Service验证 &#125; /** * 对URL进行权限配置 * 该方法定义url的访问权限，登录路径，注销 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests() .antMatchers(\"/\", \"/home\").permitAll() //任何人(包括没有经过验证的)都可以访问\"/\"和\"/home\" //.antMatchers(\"/admin/**\").access(\"hasRole('USER')\") .anyRequest().authenticated() //所有其他的URL都需要用户进行验证 .and() // 配置被拦截时的处理 .exceptionHandling() //添加无权限时的处理 .accessDeniedHandler(accessDeniedHandler) .and() .formLogin() //使用Java配置默认值设置了基于表单的验证。使用POST提交到\"/login\"时，需要用\"username\"和\"password\"进行验证 .loginPage(\"/login\") //指定在需要登录时将用户发送到的URL .permitAll() //用户可以访问formLogin()相关的任何URL .and() .logout() //注销 .permitAll(); //用户可以访问logout()相关的任何URL //权限控制 Filter http.addFilterBefore(myFilterSecurityInterceptor, FilterSecurityInterceptor.class); &#125; /*忽略静态资源*/ /*@Override public void configure(WebSecurity web) &#123; web.ignoring().antMatchers(\"/resources/static/**\"); &#125;*/&#125; 实现 UserDetailsService（认证管理器）自定义UserDetailsService 接口(认证管理器)，储存用户所有角色1234567891011121314151617181920212223242526272829303132@Servicepublic class CustomUserDetailService implements UserDetailsService &#123; @Autowired private UserMapper usersMapper; /** * 通过用户名加载与该用户的用户名、密码以及权限相关的信息 * @param username * @return * @throws UsernameNotFoundException */ @Override public UserDetails loadUserByUsername(String username) throws DisabledException &#123; User user = usersMapper.findByUserName(username); if (user != null) &#123; List&lt;Permission&gt; permissions = usersMapper.findByAdminUserId(user.getId()); List&lt;GrantedAuthority&gt; grantedAuthorities = new ArrayList &lt;&gt;(); for (Permission permission : permissions) &#123; if (permission != null &amp;&amp; permission.getName()!=null) &#123; GrantedAuthority grantedAuthority = new SimpleGrantedAuthority(permission.getName()); //1：此处将权限信息添加到 GrantedAuthority 对象中，在后面进行全权限验证时会使用GrantedAuthority 对象。 grantedAuthorities.add(grantedAuthority); &#125; &#125; return new org.springframework.security.core.userdetails.User(user.getUsername(), user.getPassword(), grantedAuthorities); &#125; else &#123; //throw new UsernameNotFoundException(\"用户名不存在\"); throw new DisabledException(\"----&gt;UserName :\" + username + \" not found!\"); &#125; &#125;&#125; 实现 PasswordEncoder（加密类）spring security 版本在 5.0 后要添加 PasswordEncoder 验证1234567891011public class MyPasswordEncoder implements PasswordEncoder &#123; @Override public String encode(CharSequence charSequence) &#123; return charSequence.toString(); &#125; @Override public boolean matches(CharSequence charSequence, String s) &#123; return s.equals(charSequence.toString()); &#125;&#125; 实现 AccessDeniedHandler (用户无权限处理器)用户无权限时处理类12345678910111213141516@Componentpublic class MyAccessDeniedHandler implements AccessDeniedHandler &#123; @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException &#123; //返回json形式的错误信息 response.setCharacterEncoding(\"UTF-8\"); response.setContentType(\"application/json\"); response.getWriter().println(\"&#123;\\\"code\\\":403,\\\"message\\\":\\\"你没有权限访问！\\\",\\\"data\\\":\\\"\\\"&#125;\"); response.getWriter().flush(); /*//无权限时跳转 response.sendRedirect(\"/home\"); */ request.getSession().invalidate(); //会话结束 &#125;&#125; 继承 AbstractSecurityInterceptor（资源管理拦截器）spring security 版本在 5.0 后要添加 PasswordEncoder 验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Servicepublic class MyFilterSecurityInterceptor extends AbstractSecurityInterceptor implements Filter &#123; //获取被拦截url所需的权限 @Autowired private FilterInvocationSecurityMetadataSource securityMetadataSource; //获取权限管理器 @Autowired public void setMyAccessDecisionManager(MyAccessDecisionManager myAccessDecisionManager) &#123; super.setAccessDecisionManager(myAccessDecisionManager); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; FilterInvocation fi = new FilterInvocation(request, response, chain); invoke(fi); &#125; public void invoke(FilterInvocation fi) throws IOException, ServletException &#123; //fi里面有一个被拦截的url //里面调用MyInvocationSecurityMetadataSource的getAttributes(Object object)这个方法获取fi对应的所有权限 //再调用MyAccessDecisionManager的decide方法来校验用户的权限是否足够 InterceptorStatusToken token = super.beforeInvocation(fi); try &#123; //执行下一个拦截器 fi.getChain().doFilter(fi.getRequest(), fi.getResponse()); &#125; finally &#123; super.afterInvocation(token, null); &#125; &#125; @Override public void destroy() &#123; &#125; @Override public Class&lt;?&gt; getSecureObjectClass() &#123; return FilterInvocation.class; &#125; @Override public SecurityMetadataSource obtainSecurityMetadataSource() &#123; return this.securityMetadataSource; &#125;&#125; 实现 FilterInvocationSecurityMetadataSource (读取url资源)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Servicepublic class MySecurityMetadataSource implements FilterInvocationSecurityMetadataSource &#123; @Autowired private UserMapper usersMapper; // 资源权限集合 private HashMap&lt;String, Collection&lt;ConfigAttribute&gt;&gt; map =null; /** * 获取权限表中所有权限 */ public void loadResourceDefine()&#123; map = new HashMap&lt;&gt;(); Collection&lt;ConfigAttribute&gt; array; ConfigAttribute cfg; List&lt;Permission&gt; permissions = usersMapper.findAllPermission(); for(Permission permission : permissions) &#123; array = new ArrayList&lt;&gt;(); cfg = new SecurityConfig(permission.getName()); //此处只添加了用户的名字，其实还可以添加更多权限的信息，例如请求方法到ConfigAttribute的集合中去。此处添加的信息将会作为MyAccessDecisionManager类的decide的第三个参数。 array.add(cfg); //用权限的getUrl() 作为map的key，用ConfigAttribute的集合作为 value， map.put(permission.getUrl(), array); &#125; &#125; //此方法是为了判定用户请求的url 是否在权限表中，如果在权限表中，则返回给 decide 方法，用来判定用户是否有此权限。如果不在权限表中则放行。 @Override public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException &#123; if(map ==null) loadResourceDefine(); //object 中包含用户请求的 url 信息 String url = ((FilterInvocation) object).getRequestUrl(); String resUrl; for(Iterator&lt;String&gt; iter = map.keySet().iterator(); iter.hasNext(); ) &#123; resUrl = iter.next(); if(resUrl .matches(url)) &#123; return map.get(resUrl); &#125; &#125; return null; &#125; @Override public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() &#123; return null; &#125; @Override public boolean supports(Class&lt;?&gt; clazz) &#123; return true; &#125;&#125; 实现 AccessDecisionManager (授权管理器)判断用户请求的资源是否能通过12345678910111213141516171819202122232425262728293031323334353637@Servicepublic class MyAccessDecisionManager implements AccessDecisionManager &#123; // decide 方法是判定是否拥有权限的决策方法， //authentication 是CustomUserService中循环添加到 GrantedAuthority 对象中的权限信息集合. //object 包含客户端发起的请求的requset信息，可转换为 HttpServletRequest request = ((FilterInvocation) object).getHttpRequest(); //configAttributes 为MyInvocationSecurityMetadataSource的getAttributes(Object object)这个方法返回的结果，此方法是为了判定用户请求的url 是否在权限表中，如果在权限表中，则返回给 decide 方法，用来判定用户是否有此权限。如果不在权限表中则放行。 @Override public void decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException, InsufficientAuthenticationException &#123; if(null== configAttributes || configAttributes.size() &lt;=0) &#123; return; &#125; ConfigAttribute c; String needRole; for(Iterator&lt;ConfigAttribute&gt; iter = configAttributes.iterator(); iter.hasNext(); ) &#123; c = iter.next(); needRole = c.getAttribute(); //authentication 为 CustomUserDetailService 中循环添加到 GrantedAuthority 对象中的权限信息集合 for(GrantedAuthority ga : authentication.getAuthorities()) &#123; if(needRole.trim().equals(ga.getAuthority())) &#123; return; &#125; &#125; &#125; throw new AccessDeniedException(\"no right\"); &#125; @Override public boolean supports(ConfigAttribute attribute) &#123; return true; &#125; @Override public boolean supports(Class&lt;?&gt; clazz) &#123; return true; &#125;&#125; 测试 踩坑加密方式WebSecurityConfig 配置文件认证规则方法”configure(AuthenticationManagerBuilder auth)” 报错java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id &quot;null&quot; 原因: spring security 版本在5.0后，之前版本中的 NoOpPasswordEncoder 被 DelegatingPasswordEncoder 取代了，而你保存在数据库中的密码没有指定加密方式,就要加个 PasswordEncoder 验证 认证管理器异常抛出CustomUserDetailService 类 loadUserByUsername 默认抛出 UsernameNotFoundException，用 DisabledException 替换 UsernameNotFoundException这里我们不抛出 UsernameNotFoundException 因为 Security 会把我们抛出的该异常捕捉并换掉，导致抛出的异常无法被 ControllerAdvice 捕捉到，无法进行统一异常处理；所以我们只需要打印正确的异常消息即可，Security 自动把异常添加到 HttpServletRequest 或 HttpSession 中 权限管理设置1.使用权限表设置，如上即权限管理流程图所示，通过实现 MyFilterSecurityInterceptor(资源管理拦截器)、MyAccessDecisionManager(授权管理器)和MySecurityMetadataSource(拦截器)进行权限拦截。 2.不通过权限表设置2.1 使用注解方式在 controller 和 WebSecurityConfig 上进行设置2.2 直接在 WebSecurityConfig 中 configure(HttpSecurity http) 方法进行设置 PS:hasRole() 方法默认含有 ‘ROLE_’ 前缀，书写方式：‘ROLE_ADMIN’ –&gt; hasRole(‘ADMIN’) 源码项目 github 源码：https://github.com/xeh1430/xehProject/tree/master/security","categories":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}],"tags":[],"keywords":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}]},{"title":"Spring Boot 使用 Spring Security (一)","slug":"20181227-springSecurity使用","date":"2018-12-27T02:26:04.000Z","updated":"2019-03-14T13:03:43.951Z","comments":true,"path":"text/springSecurity1.html","link":"","permalink":"http://yoursite.com/text/springSecurity1.html","excerpt":"","text":"Spring Security 介绍 Spring Security 是一个功能强大且可高度自定义的身份验证和访问控制框架。它是保护基于 Spring 的应用程序的事实上的标准。Spring Security 是一个专注于为 Java 应用程序提供身份验证和授权的框架。与所有 Spring 项目一样，Spring Security 的真正强大之处在于它可以轻松扩展以满足自定义要求。 Spring Security 特点 1.对身份验证和授权的全面和可扩展的支持2.防止会话固定，点击劫持，跨站点请求伪造等攻击3.Servlet API 集成4.可选与 Spring Web MVC 集成 在 Spring Boot 项目中添加 Spring Security创建 Spring Boot 已经在之前的博客中提到了，详情请查看 Spring Boot 入门 功能：创建静态页面，通过 Spring Security 权限管理，熟悉 Spring Security 的功能及配置 引入 maven 依赖Spring Security 依赖如下1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 创建静态页面创建三个静态页面：主页、hello 页面和登录页面注意：静态文件不要 WEB-INF 下，应用服务器把 WEB-INF 指为禁访目录，即直接在浏览器里是不能访问到的src/main/resources/templates/home.html 12345678910&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt; &lt;head&gt; &lt;title&gt;Spring Security Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;欢迎!&lt;/h1&gt; &lt;p&gt;点击 &lt;a th:href=\"@&#123;/hello&#125;\"&gt;这里&lt;/a&gt;进入 hello 页面.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 主页中，在 Thymeleaf 模板定义跳转到 hello 页面src/main/resources/templates/hello.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt; &lt;head&gt; &lt;title&gt;Hello World!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 th:inline=\"text\"&gt;Hello [[$&#123;#httpServletRequest.remoteUser&#125;]]!&lt;/h1&gt; &lt;form th:action=\"@&#123;/logout&#125;\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"Sign Out\"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 登录页面src/main/resources/templates/login.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt; &lt;head&gt; &lt;title&gt;Spring Security Example &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div th:if=\"$&#123;param.error&#125;\"&gt; Invalid username and password. &lt;/div&gt; &lt;div th:if=\"$&#123;param.logout&#125;\"&gt; You have been logged out. &lt;/div&gt; &lt;form th:action=\"@&#123;/login&#125;\" method=\"post\"&gt; &lt;div&gt;&lt;label&gt; User Name : &lt;input type=\"text\" name=\"username\"/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;label&gt; Password: &lt;input type=\"password\" name=\"password\"/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=\"submit\" value=\"Sign In\"/&gt;&lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 配置 Spring MVC 的配置类Web应用程序基于 Spring MVC,配置 Spring MVC 并设置视图控制器访问页面 src/main/java/hello/MvcConfig.java 12345678910111213141516171819202122232425package hello;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; /** * 配置预先配置了响应状态代码的简单自动控制器和/或视图以呈现响应主体。 * 覆盖 WebMvcConfigurer 中的 addViewControllers 同名方法 * 添加了四个视图控制器，前两个引用名称为 “home”（在其中定义 home.html）的视图， * 另一个引用名为 “hello”（在其中定义 hello.html）的视图， * 最后一个引用另一个名为 “login” 的视图 * @param registry */ public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/home\").setViewName(\"home\"); registry.addViewController(\"/\").setViewName(\"home\"); registry.addViewController(\"/hello\").setViewName(\"hello\"); registry.addViewController(\"/login\").setViewName(\"login\"); &#125;&#125; 设置Spring Securitysrc/main/java/hello/WebSecurityConfig.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package hello;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.provisioning.InMemoryUserDetailsManager;@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; /** * 该方法定义 url 的访问权限，登录路径，注销 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests() .antMatchers(\"/\", \"/home\").permitAll() //任何人(包括没有经过验证的)都可以访问 \"/\" 和 \"/home\" // .antMatchers(\"/admin/**\").hasRole(\"ADMIN\") // \"/admin/\" 开头的 URL 必须要是管理员用户，譬如 ”admin” 用户 .anyRequest().authenticated() //所有其他的 URL 都需要用户进行验证 .and() .formLogin() //使用 Java 配置默认值设置了基于表单的验证。使用 POST 提交到\"/login\"时，需要用 \"username\" 和 \"password\" 进行验证 .loginPage(\"/login\") //指定在需要登录时将用户发送到的URL .permitAll() //用户可以访问 formLogin() 相关的任何URL .and() .logout() //注销 .permitAll(); //用户可以访问 logout() 相关的任何URL。 &#125; /** * 配置创建一个 Servlet 过滤器，称为 springSecurityFilterChain 负责应用程序内的所有安全性 * （保护应用程序 URL，验证提交的用户名和密码，重定向到登录表单等） * @return */ @Bean @Override public UserDetailsService userDetailsService() &#123; UserDetails user = User.withDefaultPasswordEncoder() .username(\"user\") .password(\"password\") .roles(\"USER\") .build(); return new InMemoryUserDetailsManager(user); &#125;&#125; Spring Security 还有许多设置，想了解可以查看 WebSecurityConfig 更多常用设置；如需了解全部请查看官方文档 运行通过项目 main() 方法主入口启动项目,应用程序启动后，将浏览器指向 http://localhost:8080。你应该看到主页： 点击超链接,访问 hello 页面，因为刚才使用 Security 设置了权限，所以访问不到，直接跳转到登录页面 输入错误的用户名密码，请重新输入登录 登录成功，点击 Sign Out 按钮可注销登录 成功注销，回到登录页面 参考Spring 官方案例","categories":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}],"tags":[],"keywords":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}]},{"title":"Spring Boot 入门","slug":"20181217-springBoot入门","date":"2018-12-17T06:48:44.000Z","updated":"2019-03-14T13:03:30.516Z","comments":true,"path":"text/springBoot.html","link":"","permalink":"http://yoursite.com/text/springBoot.html","excerpt":"","text":"Spring Boot 介绍 Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 Spring Boot 特点简单、快速、方便 1.创建独立的 Spring 应用程序2.直接嵌入 Tomcat，Jetty 或 Undertow（无需部署 WAR 文件）3.提供固定的 “引用” 依赖项以简化构建配置4.尽可能自动配置 Spring 和第三方库5.提供生产就绪功能，例如指标，运行状况检查和外部化配置6.绝对没有代码生成，也不需要 XML 配置 快速入门创建 Spring Boot 有两个方式，通过访问 http://start.spring.io 获取 Spring Boot 基础项目，通过IDE创建 Spring Boot 项目。 通过 http://start.spring.io 下载 Spring Boot 基础项目1.访问 http://start.spring.io2.选择配置相关参数，如下图3.将下载的项目压缩包解压，导入IDE即可 通过 IDE 创建 Spring Boot 项目(以 idea 为例)打开idea，File -&gt; New -&gt; Project -&gt; 选择 Spring Initializr -&gt; Next -&gt; 设置包名项目名构建工具 Next -&gt; 添加依赖 Next -&gt; Finish打开项目，项目结构如下如上图所示，Spring Boot 的基础结构共三个文件: src/main/java 程序开发以及主程序入口 src/main/resources 配置文件 src/test/java 测试程序 至此，Spring Boot 项目创建成功。 创建一个简单的 Web 应用程序在 pom.xml 文件中添加 web 依赖包1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 创建 Web 控制器1234567891011121314package com.example.demo;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.bind.annotation.RequestMapping;@RestControllerpublic class HelloController &#123; @RequestMapping(\"/\") public String index() &#123; return \"Greetings from Spring Boot!\"; &#125; &#125; @RestController 让 Spring MVC 可以使用它来处理Web请求@RequestMapping(“/“) 映射/到 index() 方法。从浏览器调用或在命令行上使用curl时，该方法返回纯文本@RestController=@Controller+@ResponseBody，两个注释会导致Web请求返回数据而不是视图 在 Application 类中调用 controller12345678910111213141516171819202122232425262728293031package com.example.demo;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.Bean;import java.util.Arrays;@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @Bean public CommandLineRunner commandLineRunner(ApplicationContext ctx) &#123; return args -&gt; &#123; System.out.println(\"Let's inspect the beans provided by Spring Boot:\"); String[] beanNames = ctx.getBeanDefinitionNames(); Arrays.sort(beanNames); for (String beanName : beanNames) &#123; System.out.println(beanName); &#125; &#125;; &#125;&#125; @SpringBootApplication 是一个便利注解，包含了以下所有内容： @Configuration 标记该类作为应用程序上下文的bean定义的源。 @EnableAutoConfiguration 告诉 Spring Boot 开始根据类路径设置，其他 bean 和各种属性设置添加 bean。 @ComponentScan告诉 Spring 在包中寻找其他组件，配置和服务 hello，允许它找到控制器。main()方法使用 Spring Boot 的 SpringApplication.run() 方法来启动应用程序 运行项目控制台输出由 Spring Boot 提供的引导包访问http://localhost:8080/调用控制器页面显示： Greetings from Spring Boot!访问成功！ 单元测试添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 编写一个简单的单元测试，通过端点模拟 servlet 请求和响应1234567891011121314151617181920package com.example.demo;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoApplicationTests &#123; @Autowired private HelloController helloController; @Test public void getHello() throws Exception &#123; System.out.println(\"\\n\"+helloController.index()); &#125;&#125; 运行测试类，控制台成功输出即可。 学习资源Spring Boot 官网Spring Boot 官方入门案例","categories":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}],"tags":[],"keywords":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}]},{"title":"Web Service 调用天气预报","slug":"20181126-WebService调用天气预报","date":"2018-11-26T07:40:34.000Z","updated":"2019-03-14T13:03:26.034Z","comments":true,"path":"text/webService2.html","link":"","permalink":"http://yoursite.com/text/webService2.html","excerpt":"","text":"webservice 资源 免费 webservice 接口，包含天气预报、国内手机号码归属地查询WEB服务等多种服务http://www.webxml.com.cn/zh_cn/web_services.aspx本次项目使用天气预报的接口http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?wsdl创建 java 工程，将天气预报 wsdl 生成客户端代码，具体参考： Web Service 入门 生成代码问题解决直接使用 wsdl 调用生成代码会报错，无法生成。 修改 wsdl 文件里面的一个内容&lt;s:element ref=”s:schema”/&gt;&lt;s:any/&gt;替换为&lt;s:any minOccurs=”2” maxOccurs=”2”/&gt;注意要全部替换 调用天气预报接口成功生成代码之后，参考接口文档，编写客户端调用 天气预报接口列表http://ws.webxml.com.cn/WebServices/WeatherWS.asmx 客户端调用代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class TestWeather &#123; public static void main(String[] args) &#123; WeatherWS ws = new WeatherWS(); WeatherWSSoap soap = ws.getWeatherWSSoap(); /** * 获得天气预报数据 * 输入参数：城市/地区ID或名称 * 返回数据：一维字符串数组 */ ArrayOfString weather = soap.getWeather(\"广州\", null); List&lt;String&gt; list = weather.getString(); System.out.println(\"天气预报数据:\\n\"+list); System.out.println(); /** * 获得国外国家名称和与之对应的ID * 输入参数：无， * 返回数据：一维字符串数组 */ ArrayOfString country = soap.getRegionCountry(); List&lt;String&gt; list2 = country.getString(); System.out.println(\"国家名称对应数据:\\n\"+list2); System.out.println(); /** * 获得中国省份、直辖市、地区和与之对应的ID * 输入参数：无 * 返回数据：一维字符串数组 */ ArrayOfString province = soap.getRegionProvince(); List&lt;String&gt; list3 = province.getString(); System.out.println(\"省份地区对应数据:\\n\"+list3); System.out.println(); /** * 获得支持的城市/地区名称和与之对应的ID * 输入参数：theRegionCode = 省市、国家ID或名称 * 返回数据：一维字符串数组 */ ArrayOfString cityString = soap.getSupportCityString(\"广东\"); List&lt;String&gt; list4 = cityString.getString(); System.out.println(\"支持的城市/地区名称对应数据:\\n\"+list4); System.out.println(); &#125;&#125; 输出结果如下图","categories":[{"name":"Web Service","slug":"Web-Service","permalink":"http://yoursite.com/categories/Web-Service/"}],"tags":[],"keywords":[{"name":"Web Service","slug":"Web-Service","permalink":"http://yoursite.com/categories/Web-Service/"}]},{"title":"Web Service 入门","slug":"20181126-WebService入门","date":"2018-11-26T01:55:20.000Z","updated":"2019-03-14T13:03:22.122Z","comments":true,"path":"text/webService1.html","link":"","permalink":"http://yoursite.com/text/webService1.html","excerpt":"","text":"Web Service 简介Web Service 技术，能使得运行在不同机器上的不同应用无须借助附加的、专门的第三方软件或硬件，就可相互交换数据或集成。依据 Web Service 规范实施的应用之间，无论它们所使用的语言、平台或内部协议是什么，都可以相互交换数据。Web Service 是一种跨编程语言和跨操作系统平台的远程调用技术。 详细信息： WebService百度百科 WebService 的原理XML+XSD,SOAP 和 WSDL 就是构成 WebService 平台的三大技术SOAP 协议 = HTTP 协议 + XML 数据格式 WebService 开发可以分为服务器端开发和客户端开发两个方面对客户端而言，我们给这各类 WebService 客户端 API 传递 wsdl 文件的 url 地址，这些 API 就会创建出底层的代理类，我调用 这些代理，就可以访问到 webservice 服务。代理类把客户端的方法调用变成 soap 格式的请求数据再通过 HTTP 协议发出去，并把接收到的 soap 数据变成返回值返回。对服务端而言，各类 WebService 框架的本质就是一个大大的 Servlet，当远程调用客户端给它通过 http 协议发送过来 soap 格式的请求数据时，它分析这个数据，就知道要调用哪个 java 类的哪个方法，于是去查找或创建这个对象，并调用其方法，再把方法返回的结果包装成 soap 格式的数据，通过http响应消息回给客户端。 JAVA WebService 规范Java 中共有三种 WebService 规范，分别是 JAXM&amp;SAAJ、JAX-WS（JAX-RPC）、JAX-RS。 Web Service 服务端开发创建一个 WebService 实例，实现服务端发布，客户端获取信息的功能。使用 idea 创建 springboot 项目，配置 WebService 和 web 依赖12341.编写 WebService 接口方法public interface HelloWebService &#123; String sayHello(String name);&#125; 123456789102.实现接口，作为 webservice 提供服务类 @WebServicepublic class HelloWebServiceImpl implements HelloWebService &#123; @Override public String sayHello(String name) &#123; String said = name + \",Hello~~\"; System.out.println(said); return said; &#125;&#125; 12345678910111213141516173.发布服务@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); /* 在服务器端运行 WebServicePublish 类中的 main 方法，控制台打印出发布 webservice 成功！ 在浏览器中输入我们在 WebServicePublish 类中定义的 url?wsdl (注意一定要加 wsdl ),浏览器显示一个 xml 文档 那么我们这个 WebService 就发布成功了。 */ //定义 webService 的发布地址，提供给外界使用接口的地址 String url = \"http://localhost:8081/WebService\"; Endpoint.publish(url,new HelloWebServiceImpl()); System.out.println(\"发布 webService 成功！\"); &#125;&#125; 14.浏览器输入 `http://localhost:8081/WebService?wsdl` 测试服务是否发布成功 Web Service 客户端实现访问http://localhost:8081/WebService?wsdl，将文档下载保存为 wsdl 格式 idea 解析 wsdl 文件反向生成代码用 idea 新建一个 java 项目，导入 wsdl 文件 wsdl 文件右键点击–&gt; WebServices –&gt; Generate Java Code From Wsdl –&gt;选择解析规范 JAX-WS(idea自带) 123456789101112编写客户端public class HelloClient &#123; public static void main(String[] args) &#123; //创建服务视图，视图是从 wsdl 文件的 service 标签的 name 属性获取 HelloWebServiceImplService helloWebServiceImplService = new HelloWebServiceImplService(); //获取服务实现类，实现类从 wsdl 文件的 portType 的 name 属性获取 HelloWebServiceImpl helloWebService = helloWebServiceImplService.getPort(HelloWebServiceImpl.class); //获取查询方法，从 portType的operation 标签获取 String str = helloWebService.sayHello(\"小明\"); System.out.println(str); &#125;&#125; 直接执行，控制台成功输出","categories":[{"name":"Web Service","slug":"Web-Service","permalink":"http://yoursite.com/categories/Web-Service/"}],"tags":[],"keywords":[{"name":"Web Service","slug":"Web-Service","permalink":"http://yoursite.com/categories/Web-Service/"}]},{"title":"Axure 入门使用","slug":"20181112-Axure入门使用","date":"2018-11-12T14:26:50.000Z","updated":"2019-03-14T13:03:18.032Z","comments":true,"path":"text/axure.html","link":"","permalink":"http://yoursite.com/text/axure.html","excerpt":"","text":"Axure RP 是一款专业的快速原型设计工具。Axure RP 是美国 Axure Software Solution 公司旗舰产品，是一个专业的快速原型设计工具，让负责定义需求和规格、设计功能和界面的专家能够快速创建应用软件或 Web 网站的线框图、流程图、原型和规格说明文档。作为专业的原型设计工具，它能快速、高效的创建原型，同时支持多人协作设计和版本控制管理。 下载Axure RP 是收费软件，只有30天免费试用，可以到下面官网下载。Axure官网下载：https://www.axure.com/download 百度云资源下载链接：https://pan.baidu.com/s/1dLmf5aptMGjYQYiyozgpHg提取码：t30y 安装双击 AxureRP-setup.exe 进入安装提示页面，按 “下一步” 一直到完成安装。 打开软件，点击 “Enter License” 将 注册码.txt 中的激活码输入进去，或者进入 帮助-&gt;管理授权 输入激活码。 汉化(汉化包中附有步骤)1.关闭 Axure RP 软件，将 汉化包.rar 文件解压, 得到 lang 文件夹。2.将解压后的 lang 文件夹添加到软件的安装目录中。 使用资源提供《Axure RP 8 实战手册》pdf，可以根据内容进行练习。 在线资源Axure 官方中文网Axure RP 8 实战手册","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Spring Boot:Whitelabel Error Page 错误解决","slug":"20181102-springBoot-Whitelabel-Error-Page","date":"2018-11-11T16:00:00.000Z","updated":"2019-03-14T13:02:42.626Z","comments":true,"path":"text/springBoot-Error.html","link":"","permalink":"http://yoursite.com/text/springBoot-Error.html","excerpt":"","text":"使用 Spring Boot 构建一个简单的工程，访问报错，页面显示 Whitelabel Error Page 404，找了很久，路径没错，注解也没错，毫无头绪。最后只能求助于百度了，终于知道问题出在哪里了。原因：程序只加载启动类所在包及其子包下的内容。我不小心包启动类放在了 web 包下，导致 dao 其他包的代码加载不到。 解决方法：1.在 Application 类中加上@ComponentScan(basePackages = {&quot;com.example&quot;})多个之间用”,”分隔。2.将启动类放在正确位置。","categories":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}],"tags":[],"keywords":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}]},{"title":"Markdown 入门","slug":"20181102-markdown入门","date":"2018-11-02T09:29:07.000Z","updated":"2019-03-14T13:02:37.309Z","comments":true,"path":"text/markdown.html","link":"","permalink":"http://yoursite.com/text/markdown.html","excerpt":"Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown 的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。","text":"Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown 的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。 标题以#表示，一个#最大，共六级 123456# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 一级标题二级标题三级标题四级标题五级标题六级标题 列表无序列表用 - + * 任何一种都可以12345678#### 无序列表 - 足球 + 篮球 * 乒乓球#### 有序列表 1. 足球 2. 篮球 3. 乒乓球 无序列表 足球 篮球 乒乓球 有序列表 足球 篮球 乒乓球 引用只需要在文本前加入 &gt; 这种尖括号（大于号）即可引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; 1234&gt; &amp;gt; &gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 &gt;这是引用的内容 这是引用的内容 这是引用的内容 图片与链接图片为：![]()链接为：[]()12![图片](https://mouapp.com.Mou_128.png) [百度](www.baidu.com) 链接：百度 粗体、斜体与删除线1234**粗体** *斜体* ***加粗并倾斜*** ~~删除线~~ 粗体粗体斜体加粗并倾斜删除线 表格12345| Tables | Are | Cool | | ------------- |:-------------:| -----:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码框 两个 ` 把代码包含(单行代码)三个 ` 报代码包含(多行代码) System.out.println(&quot;Hello MarkDown!&quot;)1System.out.println(\"Hello MarkDown!\") 字体、字号与颜色1234567&lt;font face=\"黑体\"&gt;我是黑体字&lt;/font&gt;&lt;font face=\"微软雅黑\"&gt;我是微软雅黑&lt;/font&gt;&lt;font face=\"STCAIYUN\"&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=5 face=\"黑体\"&gt;color=#0099ff size=72 face=\"黑体\"&lt;/font&gt;Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3。&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;&lt;font color=gray size=72&gt;color=gray&lt;/font&gt; 我是黑体字我是微软雅黑我是华文彩云color=#0099ff size=5 face=”黑体”color=#00ffffcolor=gray 居中&lt;center&gt;居中显示&lt;center&gt; 居中显示 分割线分割线的语法只需要三个 * 号1234-------*** **** 参考：[1]: https://www.jianshu.com/p/1e402922ee32/","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Hexo 入门","slug":"20181016-Hexo入门","date":"2018-10-15T16:00:00.000Z","updated":"2019-03-14T12:59:22.835Z","comments":true,"path":"text/hello-world.html","link":"","permalink":"http://yoursite.com/text/hello-world.html","excerpt":"","text":"Hexo官网Hexo文档Hexo GitHub 快速开始新建文章12$ hexo new \"My New Post\"$ hexo n \"My New Post\" (简写) 更多信息: Writing 启动服务12$ hexo server$ hexo s (简写) 更多信息: Server 生成静态文件12$ hexo generate$ hexo g (简写) 更多信息: Generating 部署到远程站点12$ hexo deploy$ hexo d (简写) 更多信息: Deployment","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]}]}
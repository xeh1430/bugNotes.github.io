{"meta":{"title":"xeh的学习笔记","subtitle":"将记录当成一种习惯","description":"路漫漫其修远兮！","author":"xeh","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Spring Boot 使用 Spring Security (二)","slug":"SpringSecurity2","date":"2019-01-30T12:38:46.000Z","updated":"2019-02-12T08:56:58.769Z","comments":true,"path":"2019/01/30/SpringSecurity2/","link":"","permalink":"http://yoursite.com/2019/01/30/SpringSecurity2/","excerpt":"","text":"介绍 使用 springboot+mybatis＋SpringSecurity 实现数据库动态的管理用户、角色、权限管理。 细分角色和权限，并将用户、角色、权限和资源均采用数据库存储，并且自定义滤器，代替原有的FilterSecurityInterceptor过滤器，并分别实现 AccessDecisionManager、InvocationSecurityMetadataSourceService 和 serDetailsService，并在配置文件中进行相应配置。 数据库表设计12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#创建用户表create table user( id int not null primary key comment'主键id', username varchar(50) not null comment'用户名', password varchar(50) not null comment'密码')#角色表create table role( id int not null primary key comment'主键id', name varchar(50) not null comment'角色名')#用户角色表create table user_role( user_id varchar(50) not null comment'用户id', role_id varchar(50) not null comment'角色id')#权限表create table permission ( id int unsigned not null auto_increment comment'主键id', name varchar (200) not null comment'角色名', description varchar (200) default null comment'描述', url varchar (200) not null comment'路径', pid int default null comment'上级id', primary key (id))#角色权限中间表create table permission_role ( id int unsigned not null auto_increment comment'主键id', role_id int unsigned not null comment'角色id', permission_id int unsigned not null comment'权限id', primary key (id))#插入用户INSERT INTO user(id,username,password)VALUES('1',admin','admin');INSERT INTO user(id,username,password)VALUES('2',user','user');INSERT INTO user(id,username,password)VALUES('3',test','test');#插入角色INSERT INTO role VALUES ('1', 'ROLE_ADMIN'); INSERT INTO role VALUES ('2', 'ROLE_USER'); INSERT INTO user_role VALUES ('1', '1'); INSERT INTO user_role VALUES ('1', '2'); INSERT INTO user_role VALUES ('2', '2'); INSERT INTO permission VALUES ('1', 'ROLE_USER', 'user', '/admin/home', null);INSERT INTO permission_role VALUES ('1', '2', '1')); 引入 maven 依赖pom 文件123456789101112131415161718192021222324252627282930313233343536373839404142&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql版本根据自身情况调整--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--thymeleaf页面展示控制--&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity4&lt;/artifactId&gt; &lt;version&gt;3.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置数据库信息123456789spring.datasource.url=jdbc:mysql://localhost:3306/worldspring.datasource.username=rootspring.datasource.password=123456spring.jpa.database=mysqlspring.datasource.driver-class-name=com.mysql.jdbc.Driverserver.port=8088 mybatis.mapper-locations=classpath:UserMapper.xml 创建 pojo/dao/mapper/controller 文件PS: 功能比较简单，所以省略 service 文件，直接调用 dao 层文件；并将权限表的相关查询操作写在同一 mapper 文件 User.java12345678public class User &#123; private int id; private String username; private String password; private List&lt;Role&gt; roles; /* Getter 和 Setter 自行补充 */&#125; Role.java123456public class Role &#123; private int id; private String name; /* Getter 和 Setter 自行补充 */&#125; Permission.java12345678910111213public class Role &#123; private int id; //权限名称 private String name; //权限描述 private String descritpion; //授权链接 private String url; //父节点id private int pid; /* Getter 和 Setter 自行补充 */&#125; UserMapper.java 12345678910@Mapper@Repositorypublic interface UserMapper &#123; //根据用户名查找用户所有权限信息 User findByUserName(String username); //获取所有权限信息 List&lt;Permission&gt; findAllPermission(); // List&lt;Permission&gt; findByAdminUserId(int userId);&#125; UserMapper.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.xeh.security.dao.UserMapper\"&gt; &lt;resultMap id=\"userMap\" type=\"com.xeh.security.model.User\"&gt; &lt;id property=\"id\" column=\"ID\"/&gt; &lt;result property=\"username\" column=\"username\"/&gt; &lt;result property=\"password\" column=\"PASSWORD\"/&gt; &lt;collection property=\"roles\" ofType=\"com.xeh.security.model.Role\"&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findByUserName\" parameterType=\"String\" resultMap=\"userMap\"&gt; select u.* ,r.name from user u LEFT JOIN user_role sru on u.id = sru.user_id LEFT JOIN role r on sru.role_id = r.id where username = #&#123;username&#125; &lt;/select&gt; &lt;select id=\"findAllPermission\" resultType=\"com.xeh.security.model.Permission\"&gt; select * from permission &lt;/select&gt; &lt;select id=\"findByAdminUserId\" parameterType=\"int\" resultType=\"com.xeh.security.model.Permission\"&gt; select p.* from user u left join user_role sru on u.id = sru.user_id left join role r on sru.role_id = r.id left join permission_role spr on spr.role_id = r.id left join permission p on p.id = spr.permission_id where u.id = #&#123;userId&#125; &lt;/select&gt;&lt;/mapper&gt; HelloController.java1234567891011121314151617@Controllerpublic class HelloController &#123; @RequestMapping(\"/admin/hello\") public String index()&#123; return \"hello\"; &#125; @RequestMapping(value =&#123;\"\",\"/\",\"/home\"&#125;) public String home()&#123; return \"home\"; &#125; @RequestMapping(\"/login\") public String login()&#123; return \"login\"; &#125;&#125; 页面文件home.html1234567891011&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt;&lt;head&gt; &lt;title&gt;Spring Security Home&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;欢迎!&lt;/h1&gt;&lt;p&gt;点击 &lt;a th:href=\"@&#123;/admin/hello&#125;\"&gt;这里&lt;/a&gt;进入hello页面.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; hello.html123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt;&lt;head&gt; &lt;title&gt;Hello World!&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:inline=\"text\"&gt;Hello [[$&#123;#httpServletRequest.remoteUser&#125;]]!&lt;/h1&gt;&lt;div sec:authorize=\"isAuthenticated()\"&gt; &lt;!-- 用户认证通过才能才显示 --&gt; &lt;p&gt;用户名:&lt;span sec:authentication=\"name\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;权限:&lt;span sec:authentication=\"principal.authorities\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;div sec:authorize=\"hasRole('ADMIN')\"&gt; &lt;!-- 用户角色为“ADMIN”才显示 --&gt; &lt;p&gt;【管理员】才能看见的内容&lt;/p&gt;&lt;/div&gt;&lt;div sec:authorize=\"hasRole('USER')\"&gt; &lt;!-- 用户角色具有“USER”权限才显示 --&gt; &lt;p&gt;【普通用户】才能看到的内容&lt;/p&gt;&lt;/div&gt;&lt;form th:action=\"@&#123;/logout&#125;\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"注销\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; login.html12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:if=\"$&#123;param.error&#125;\"&gt; 用户名或密码错误&lt;/div&gt;&lt;div th:if=\"$&#123;param.logout&#125;\"&gt; 账户已退出登录&lt;/div&gt;&lt;form th:action=\"@&#123;/login&#125;\" method=\"post\" action=\"/login\"&gt; &lt;div&gt;&lt;label&gt; 用户名: &lt;input type=\"text\" name=\"username\"/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;label&gt; 密 码: &lt;input type=\"password\" name=\"password\"/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=\"submit\" value=\"登录\"/&gt;&lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 这样，我们就搭好了连接数据库的 springboot 项目，接下来就是添加权限了 流程图SpringSecurity 登录认证流程图 SpringSecurity 权限管理流程图 添加 SpringSecurity,实现登录及权限验证创建 Spring Security 的配置类 WebSecurityConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Configuration@EnableWebSecurity //使得Spring Security提供并且支持了Spring MVC的集成public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; //用户无权限拦截处理类 @Autowired private MyAccessDeniedHandler accessDeniedHandler; //授权管理 @Autowired private MyFilterSecurityInterceptor myFilterSecurityInterceptor; //注册UserDetailsService 的bean，通过用户名加载与该用户的用户名、密码以及权限相关的信息 @Bean UserDetailsService customUserService()&#123; //注册UserDetailsService 的bean return new CustomUserDetailService(); &#125; /*定义认证规则*/ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(customUserService()).passwordEncoder(new MyPasswordEncoder()); //user Details Service验证 &#125; /** * 对URL进行权限配置 * 该方法定义url的访问权限，登录路径，注销 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests() .antMatchers(\"/\", \"/home\").permitAll() //任何人(包括没有经过验证的)都可以访问\"/\"和\"/home\" //.antMatchers(\"/admin/**\").access(\"hasRole('USER')\") .anyRequest().authenticated() //所有其他的URL都需要用户进行验证 .and() // 配置被拦截时的处理 .exceptionHandling() //添加无权限时的处理 .accessDeniedHandler(accessDeniedHandler) .and() .formLogin() //使用Java配置默认值设置了基于表单的验证。使用POST提交到\"/login\"时，需要用\"username\"和\"password\"进行验证 .loginPage(\"/login\") //指定在需要登录时将用户发送到的URL .permitAll() //用户可以访问formLogin()相关的任何URL .and() .logout() //注销 .permitAll(); //用户可以访问logout()相关的任何URL //权限控制 Filter http.addFilterBefore(myFilterSecurityInterceptor, FilterSecurityInterceptor.class); &#125; /*忽略静态资源*/ /*@Override public void configure(WebSecurity web) &#123; web.ignoring().antMatchers(\"/resources/static/**\"); &#125;*/&#125; 实现 UserDetailsService（认证管理器）自定义UserDetailsService 接口(认证管理器)，储存用户所有角色1234567891011121314151617181920212223242526272829303132@Servicepublic class CustomUserDetailService implements UserDetailsService &#123; @Autowired private UserMapper usersMapper; /** * 通过用户名加载与该用户的用户名、密码以及权限相关的信息 * @param username * @return * @throws UsernameNotFoundException */ @Override public UserDetails loadUserByUsername(String username) throws DisabledException &#123; User user = usersMapper.findByUserName(username); if (user != null) &#123; List&lt;Permission&gt; permissions = usersMapper.findByAdminUserId(user.getId()); List&lt;GrantedAuthority&gt; grantedAuthorities = new ArrayList &lt;&gt;(); for (Permission permission : permissions) &#123; if (permission != null &amp;&amp; permission.getName()!=null) &#123; GrantedAuthority grantedAuthority = new SimpleGrantedAuthority(permission.getName()); //1：此处将权限信息添加到 GrantedAuthority 对象中，在后面进行全权限验证时会使用GrantedAuthority 对象。 grantedAuthorities.add(grantedAuthority); &#125; &#125; return new org.springframework.security.core.userdetails.User(user.getUsername(), user.getPassword(), grantedAuthorities); &#125; else &#123; //throw new UsernameNotFoundException(\"用户名不存在\"); throw new DisabledException(\"----&gt;UserName :\" + username + \" not found!\"); &#125; &#125;&#125; 实现 PasswordEncoder（加密类）spring security 版本在 5.0 后要添加 PasswordEncoder 验证1234567891011public class MyPasswordEncoder implements PasswordEncoder &#123; @Override public String encode(CharSequence charSequence) &#123; return charSequence.toString(); &#125; @Override public boolean matches(CharSequence charSequence, String s) &#123; return s.equals(charSequence.toString()); &#125;&#125; 实现 AccessDeniedHandler (用户无权限处理器)用户无权限时处理类12345678910111213141516@Componentpublic class MyAccessDeniedHandler implements AccessDeniedHandler &#123; @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException &#123; //返回json形式的错误信息 response.setCharacterEncoding(\"UTF-8\"); response.setContentType(\"application/json\"); response.getWriter().println(\"&#123;\\\"code\\\":403,\\\"message\\\":\\\"你没有权限访问！\\\",\\\"data\\\":\\\"\\\"&#125;\"); response.getWriter().flush(); /*//无权限时跳转 response.sendRedirect(\"/home\"); */ request.getSession().invalidate(); //会话结束 &#125;&#125; 继承 AbstractSecurityInterceptor（资源管理拦截器）spring security 版本在 5.0 后要添加 PasswordEncoder 验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Servicepublic class MyFilterSecurityInterceptor extends AbstractSecurityInterceptor implements Filter &#123; //获取被拦截url所需的权限 @Autowired private FilterInvocationSecurityMetadataSource securityMetadataSource; //获取权限管理器 @Autowired public void setMyAccessDecisionManager(MyAccessDecisionManager myAccessDecisionManager) &#123; super.setAccessDecisionManager(myAccessDecisionManager); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; FilterInvocation fi = new FilterInvocation(request, response, chain); invoke(fi); &#125; public void invoke(FilterInvocation fi) throws IOException, ServletException &#123; //fi里面有一个被拦截的url //里面调用MyInvocationSecurityMetadataSource的getAttributes(Object object)这个方法获取fi对应的所有权限 //再调用MyAccessDecisionManager的decide方法来校验用户的权限是否足够 InterceptorStatusToken token = super.beforeInvocation(fi); try &#123; //执行下一个拦截器 fi.getChain().doFilter(fi.getRequest(), fi.getResponse()); &#125; finally &#123; super.afterInvocation(token, null); &#125; &#125; @Override public void destroy() &#123; &#125; @Override public Class&lt;?&gt; getSecureObjectClass() &#123; return FilterInvocation.class; &#125; @Override public SecurityMetadataSource obtainSecurityMetadataSource() &#123; return this.securityMetadataSource; &#125;&#125; 实现 FilterInvocationSecurityMetadataSource (读取url资源)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Servicepublic class MySecurityMetadataSource implements FilterInvocationSecurityMetadataSource &#123; @Autowired private UserMapper usersMapper; // 资源权限集合 private HashMap&lt;String, Collection&lt;ConfigAttribute&gt;&gt; map =null; /** * 获取权限表中所有权限 */ public void loadResourceDefine()&#123; map = new HashMap&lt;&gt;(); Collection&lt;ConfigAttribute&gt; array; ConfigAttribute cfg; List&lt;Permission&gt; permissions = usersMapper.findAllPermission(); for(Permission permission : permissions) &#123; array = new ArrayList&lt;&gt;(); cfg = new SecurityConfig(permission.getName()); //此处只添加了用户的名字，其实还可以添加更多权限的信息，例如请求方法到ConfigAttribute的集合中去。此处添加的信息将会作为MyAccessDecisionManager类的decide的第三个参数。 array.add(cfg); //用权限的getUrl() 作为map的key，用ConfigAttribute的集合作为 value， map.put(permission.getUrl(), array); &#125; &#125; //此方法是为了判定用户请求的url 是否在权限表中，如果在权限表中，则返回给 decide 方法，用来判定用户是否有此权限。如果不在权限表中则放行。 @Override public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException &#123; if(map ==null) loadResourceDefine(); //object 中包含用户请求的 url 信息 String url = ((FilterInvocation) object).getRequestUrl(); String resUrl; for(Iterator&lt;String&gt; iter = map.keySet().iterator(); iter.hasNext(); ) &#123; resUrl = iter.next(); if(resUrl .matches(url)) &#123; return map.get(resUrl); &#125; &#125; return null; &#125; @Override public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() &#123; return null; &#125; @Override public boolean supports(Class&lt;?&gt; clazz) &#123; return true; &#125;&#125; 实现 AccessDecisionManager (授权管理器)判断用户请求的资源是否能通过12345678910111213141516171819202122232425262728293031323334353637@Servicepublic class MyAccessDecisionManager implements AccessDecisionManager &#123; // decide 方法是判定是否拥有权限的决策方法， //authentication 是CustomUserService中循环添加到 GrantedAuthority 对象中的权限信息集合. //object 包含客户端发起的请求的requset信息，可转换为 HttpServletRequest request = ((FilterInvocation) object).getHttpRequest(); //configAttributes 为MyInvocationSecurityMetadataSource的getAttributes(Object object)这个方法返回的结果，此方法是为了判定用户请求的url 是否在权限表中，如果在权限表中，则返回给 decide 方法，用来判定用户是否有此权限。如果不在权限表中则放行。 @Override public void decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException, InsufficientAuthenticationException &#123; if(null== configAttributes || configAttributes.size() &lt;=0) &#123; return; &#125; ConfigAttribute c; String needRole; for(Iterator&lt;ConfigAttribute&gt; iter = configAttributes.iterator(); iter.hasNext(); ) &#123; c = iter.next(); needRole = c.getAttribute(); //authentication 为 CustomUserDetailService 中循环添加到 GrantedAuthority 对象中的权限信息集合 for(GrantedAuthority ga : authentication.getAuthorities()) &#123; if(needRole.trim().equals(ga.getAuthority())) &#123; return; &#125; &#125; &#125; throw new AccessDeniedException(\"no right\"); &#125; @Override public boolean supports(ConfigAttribute attribute) &#123; return true; &#125; @Override public boolean supports(Class&lt;?&gt; clazz) &#123; return true; &#125;&#125; 测试 注意事项加密方式WebSecurityConfig 配置文件认证规则方法”configure(AuthenticationManagerBuilder auth)” 报错java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id &quot;null&quot; 原因: spring security 版本在5.0后，之前版本中的 NoOpPasswordEncoder 被 DelegatingPasswordEncoder 取代了，而你保存在数据库中的密码没有指定加密方式,就要加个 PasswordEncoder 验证 认证管理器异常抛出CustomUserDetailService 类 loadUserByUsername 默认抛出 UsernameNotFoundException，用 DisabledException 替换 UsernameNotFoundException这里我们不抛出 UsernameNotFoundException 因为 Security 会把我们抛出的该异常捕捉并换掉，导致抛出的异常无法被 ControllerAdvice 捕捉到，无法进行统一异常处理；所以我们只需要打印正确的异常消息即可，Security 自动把异常添加到 HttpServletRequest 或 HttpSession 中 权限管理设置1.使用权限表设置，如上即权限管理流程图所示，通过实现 MyFilterSecurityInterceptor(资源管理拦截器)、MyAccessDecisionManager(授权管理器)和MySecurityMetadataSource(拦截器)进行权限拦截。 2.不通过权限表设置2.1 使用注解方式在 controller 和 WebSecurityConfig 上进行设置2.2 直接在 WebSecurityConfig 中 configure(HttpSecurity http) 方法进行设置 PS:hasRole() 方法默认含有 ‘ROLE_’ 前缀，书写方式：‘ROLE_ADMIN’ –&gt; hasRole(‘ADMIN’)","categories":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}],"tags":[],"keywords":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}]},{"title":"Spring Boot 使用 Spring Security (一)","slug":"Spring-Security","date":"2018-12-27T02:26:04.000Z","updated":"2018-12-27T09:58:52.080Z","comments":true,"path":"2018/12/27/Spring-Security/","link":"","permalink":"http://yoursite.com/2018/12/27/Spring-Security/","excerpt":"","text":"Spring Security 介绍 Spring Security 是一个功能强大且可高度自定义的身份验证和访问控制框架。它是保护基于 Spring 的应用程序的事实上的标准。Spring Security 是一个专注于为 Java 应用程序提供身份验证和授权的框架。与所有 Spring 项目一样，Spring Security 的真正强大之处在于它可以轻松扩展以满足自定义要求。 Spring Security 特点 1.对身份验证和授权的全面和可扩展的支持2.防止会话固定，点击劫持，跨站点请求伪造等攻击3.Servlet API 集成4.可选与 Spring Web MVC 集成 在 Spring Boot 项目中添加 Spring Security创建 Spring Boot 已经在之前的博客中提到了，详情请查看 Spring Boot 入门 功能：创建静态页面，通过 Spring Security 权限管理，熟悉 Spring Security 的功能及配置 引入 maven 依赖Spring Security 依赖如下1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 创建静态页面创建三个静态页面：主页、hello 页面和登录页面注意：静态文件不要 WEB-INF 下，应用服务器把 WEB-INF 指为禁访目录，即直接在浏览器里是不能访问到的src/main/resources/templates/home.html 12345678910&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt; &lt;head&gt; &lt;title&gt;Spring Security Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;欢迎!&lt;/h1&gt; &lt;p&gt;点击 &lt;a th:href=\"@&#123;/hello&#125;\"&gt;这里&lt;/a&gt;进入 hello 页面.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 主页中，在 Thymeleaf 模板定义跳转到 hello 页面src/main/resources/templates/hello.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt; &lt;head&gt; &lt;title&gt;Hello World!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 th:inline=\"text\"&gt;Hello [[$&#123;#httpServletRequest.remoteUser&#125;]]!&lt;/h1&gt; &lt;form th:action=\"@&#123;/logout&#125;\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"Sign Out\"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 登录页面src/main/resources/templates/login.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt; &lt;head&gt; &lt;title&gt;Spring Security Example &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div th:if=\"$&#123;param.error&#125;\"&gt; Invalid username and password. &lt;/div&gt; &lt;div th:if=\"$&#123;param.logout&#125;\"&gt; You have been logged out. &lt;/div&gt; &lt;form th:action=\"@&#123;/login&#125;\" method=\"post\"&gt; &lt;div&gt;&lt;label&gt; User Name : &lt;input type=\"text\" name=\"username\"/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;label&gt; Password: &lt;input type=\"password\" name=\"password\"/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=\"submit\" value=\"Sign In\"/&gt;&lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 配置 Spring MVC 的配置类Web应用程序基于 Spring MVC,配置 Spring MVC 并设置视图控制器访问页面 src/main/java/hello/MvcConfig.java 12345678910111213141516171819202122232425package hello;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; /** * 配置预先配置了响应状态代码的简单自动控制器和/或视图以呈现响应主体。 * 覆盖 WebMvcConfigurer 中的 addViewControllers 同名方法 * 添加了四个视图控制器，前两个引用名称为 “home”（在其中定义 home.html）的视图， * 另一个引用名为 “hello”（在其中定义 hello.html）的视图， * 最后一个引用另一个名为 “login” 的视图 * @param registry */ public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/home\").setViewName(\"home\"); registry.addViewController(\"/\").setViewName(\"home\"); registry.addViewController(\"/hello\").setViewName(\"hello\"); registry.addViewController(\"/login\").setViewName(\"login\"); &#125;&#125; 设置Spring Securitysrc/main/java/hello/WebSecurityConfig.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package hello;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.provisioning.InMemoryUserDetailsManager;@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; /** * 该方法定义 url 的访问权限，登录路径，注销 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests() .antMatchers(\"/\", \"/home\").permitAll() //任何人(包括没有经过验证的)都可以访问 \"/\" 和 \"/home\" // .antMatchers(\"/admin/**\").hasRole(\"ADMIN\") // \"/admin/\" 开头的 URL 必须要是管理员用户，譬如 ”admin” 用户 .anyRequest().authenticated() //所有其他的 URL 都需要用户进行验证 .and() .formLogin() //使用 Java 配置默认值设置了基于表单的验证。使用 POST 提交到\"/login\"时，需要用 \"username\" 和 \"password\" 进行验证 .loginPage(\"/login\") //指定在需要登录时将用户发送到的URL .permitAll() //用户可以访问 formLogin() 相关的任何URL .and() .logout() //注销 .permitAll(); //用户可以访问 logout() 相关的任何URL。 &#125; /** * 配置创建一个 Servlet 过滤器，称为 springSecurityFilterChain 负责应用程序内的所有安全性 * （保护应用程序 URL，验证提交的用户名和密码，重定向到登录表单等） * @return */ @Bean @Override public UserDetailsService userDetailsService() &#123; UserDetails user = User.withDefaultPasswordEncoder() .username(\"user\") .password(\"password\") .roles(\"USER\") .build(); return new InMemoryUserDetailsManager(user); &#125;&#125; Spring Security 还有许多设置，想了解可以查看 WebSecurityConfig 更多常用设置；如需了解全部请查看官方文档 运行通过项目 main() 方法主入口启动项目,应用程序启动后，将浏览器指向 http://localhost:8080。你应该看到主页： 点击超链接,访问 hello 页面，因为刚才使用 Security 设置了权限，所以访问不到，直接跳转到登录页面 输入错误的用户名密码，请重新输入登录 登录成功，点击 Sign Out 按钮可注销登录 成功注销，回到登录页面 参考Spring 官方案例","categories":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}],"tags":[],"keywords":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}]},{"title":"Spring Boot 入门","slug":"Spring-Boot-Create","date":"2018-12-17T06:48:44.000Z","updated":"2018-12-27T09:19:54.474Z","comments":true,"path":"2018/12/17/Spring-Boot-Create/","link":"","permalink":"http://yoursite.com/2018/12/17/Spring-Boot-Create/","excerpt":"","text":"Spring Boot 介绍 Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 Spring Boot 特点简单、快速、方便 1.创建独立的 Spring 应用程序2.直接嵌入 Tomcat，Jetty 或 Undertow（无需部署 WAR 文件）3.提供固定的 “引用” 依赖项以简化构建配置4.尽可能自动配置 Spring 和第三方库5.提供生产就绪功能，例如指标，运行状况检查和外部化配置6.绝对没有代码生成，也不需要 XML 配置 快速入门创建 Spring Boot 有两个方式，通过访问 http://start.spring.io 获取 Spring Boot 基础项目，通过IDE创建 Spring Boot 项目。 通过 http://start.spring.io 下载 Spring Boot 基础项目1.访问 http://start.spring.io2.选择配置相关参数，如下图3.将下载的项目压缩包解压，导入IDE即可 通过 IDE 创建 Spring Boot 项目(以 idea 为例)打开idea，File -&gt; New -&gt; Project -&gt; 选择 Spring Initializr -&gt; Next -&gt; 设置包名项目名构建工具 Next -&gt; 添加依赖 Next -&gt; Finish打开项目，项目结构如下如上图所示，Spring Boot 的基础结构共三个文件: src/main/java 程序开发以及主程序入口 src/main/resources 配置文件 src/test/java 测试程序 至此，Spring Boot 项目创建成功。 创建一个简单的 Web 应用程序在 pom.xml 文件中添加 web 依赖包1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 创建 Web 控制器1234567891011121314package com.example.demo;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.bind.annotation.RequestMapping;@RestControllerpublic class HelloController &#123; @RequestMapping(\"/\") public String index() &#123; return \"Greetings from Spring Boot!\"; &#125; &#125; @RestController 让 Spring MVC 可以使用它来处理Web请求@RequestMapping(“/“) 映射/到 index() 方法。从浏览器调用或在命令行上使用curl时，该方法返回纯文本@RestController=@Controller+@ResponseBody，两个注释会导致Web请求返回数据而不是视图 在 Application 类中调用 controller12345678910111213141516171819202122232425262728293031package com.example.demo;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.Bean;import java.util.Arrays;@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @Bean public CommandLineRunner commandLineRunner(ApplicationContext ctx) &#123; return args -&gt; &#123; System.out.println(\"Let's inspect the beans provided by Spring Boot:\"); String[] beanNames = ctx.getBeanDefinitionNames(); Arrays.sort(beanNames); for (String beanName : beanNames) &#123; System.out.println(beanName); &#125; &#125;; &#125;&#125; @SpringBootApplication 是一个便利注解，包含了以下所有内容： @Configuration 标记该类作为应用程序上下文的bean定义的源。 @EnableAutoConfiguration 告诉 Spring Boot 开始根据类路径设置，其他 bean 和各种属性设置添加 bean。 @ComponentScan告诉 Spring 在包中寻找其他组件，配置和服务 hello，允许它找到控制器。main()方法使用 Spring Boot 的 SpringApplication.run() 方法来启动应用程序 运行项目控制台输出由 Spring Boot 提供的引导包访问http://localhost:8080/调用控制器页面显示： Greetings from Spring Boot!访问成功！ 单元测试添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 编写一个简单的单元测试，通过端点模拟 servlet 请求和响应1234567891011121314151617181920package com.example.demo;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoApplicationTests &#123; @Autowired private HelloController helloController; @Test public void getHello() throws Exception &#123; System.out.println(\"\\n\"+helloController.index()); &#125;&#125; 运行测试类，控制台成功输出即可。 学习资源Spring Boot 官网Spring Boot 官方入门案例","categories":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}],"tags":[],"keywords":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}]},{"title":"Web Service 调用天气预报","slug":"Web-Service-Weather","date":"2018-11-26T07:40:34.000Z","updated":"2018-12-27T09:27:29.399Z","comments":true,"path":"2018/11/26/Web-Service-Weather/","link":"","permalink":"http://yoursite.com/2018/11/26/Web-Service-Weather/","excerpt":"","text":"webservice 资源 免费 webservice 接口，包含天气预报、国内手机号码归属地查询WEB服务等多种服务http://www.webxml.com.cn/zh_cn/web_services.aspx本次项目使用天气预报的接口http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?wsdl创建 java 工程，将天气预报 wsdl 生成客户端代码，具体参考： Web Service 入门 生成代码问题解决直接使用 wsdl 调用生成代码会报错，无法生成。 修改 wsdl 文件里面的一个内容&lt;s:element ref=”s:schema”/&gt;&lt;s:any/&gt;替换为&lt;s:any minOccurs=”2” maxOccurs=”2”/&gt;注意要全部替换 调用天气预报接口成功生成代码之后，参考接口文档，编写客户端调用 天气预报接口列表http://ws.webxml.com.cn/WebServices/WeatherWS.asmx 客户端调用代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class TestWeather &#123; public static void main(String[] args) &#123; WeatherWS ws = new WeatherWS(); WeatherWSSoap soap = ws.getWeatherWSSoap(); /** * 获得天气预报数据 * 输入参数：城市/地区ID或名称 * 返回数据：一维字符串数组 */ ArrayOfString weather = soap.getWeather(\"广州\", null); List&lt;String&gt; list = weather.getString(); System.out.println(\"天气预报数据:\\n\"+list); System.out.println(); /** * 获得国外国家名称和与之对应的ID * 输入参数：无， * 返回数据：一维字符串数组 */ ArrayOfString country = soap.getRegionCountry(); List&lt;String&gt; list2 = country.getString(); System.out.println(\"国家名称对应数据:\\n\"+list2); System.out.println(); /** * 获得中国省份、直辖市、地区和与之对应的ID * 输入参数：无 * 返回数据：一维字符串数组 */ ArrayOfString province = soap.getRegionProvince(); List&lt;String&gt; list3 = province.getString(); System.out.println(\"省份地区对应数据:\\n\"+list3); System.out.println(); /** * 获得支持的城市/地区名称和与之对应的ID * 输入参数：theRegionCode = 省市、国家ID或名称 * 返回数据：一维字符串数组 */ ArrayOfString cityString = soap.getSupportCityString(\"广东\"); List&lt;String&gt; list4 = cityString.getString(); System.out.println(\"支持的城市/地区名称对应数据:\\n\"+list4); System.out.println(); &#125;&#125; 输出结果如下图","categories":[{"name":"Web Service","slug":"Web-Service","permalink":"http://yoursite.com/categories/Web-Service/"}],"tags":[],"keywords":[{"name":"Web Service","slug":"Web-Service","permalink":"http://yoursite.com/categories/Web-Service/"}]},{"title":"Web Service 入门","slug":"Web-Service-Client","date":"2018-11-26T01:55:20.000Z","updated":"2018-12-27T09:25:09.322Z","comments":true,"path":"2018/11/26/Web-Service-Client/","link":"","permalink":"http://yoursite.com/2018/11/26/Web-Service-Client/","excerpt":"","text":"Web Service 简介Web Service 技术，能使得运行在不同机器上的不同应用无须借助附加的、专门的第三方软件或硬件，就可相互交换数据或集成。依据 Web Service 规范实施的应用之间，无论它们所使用的语言、平台或内部协议是什么，都可以相互交换数据。Web Service 是一种跨编程语言和跨操作系统平台的远程调用技术。 详细信息： WebService百度百科 WebService 的原理XML+XSD,SOAP 和 WSDL 就是构成 WebService 平台的三大技术SOAP 协议 = HTTP 协议 + XML 数据格式 WebService 开发可以分为服务器端开发和客户端开发两个方面对客户端而言，我们给这各类 WebService 客户端 API 传递 wsdl 文件的 url 地址，这些 API 就会创建出底层的代理类，我调用 这些代理，就可以访问到 webservice 服务。代理类把客户端的方法调用变成 soap 格式的请求数据再通过 HTTP 协议发出去，并把接收到的 soap 数据变成返回值返回。对服务端而言，各类 WebService 框架的本质就是一个大大的 Servlet，当远程调用客户端给它通过 http 协议发送过来 soap 格式的请求数据时，它分析这个数据，就知道要调用哪个 java 类的哪个方法，于是去查找或创建这个对象，并调用其方法，再把方法返回的结果包装成 soap 格式的数据，通过http响应消息回给客户端。 JAVA WebService 规范Java 中共有三种 WebService 规范，分别是 JAXM&amp;SAAJ、JAX-WS（JAX-RPC）、JAX-RS。 Web Service 服务端开发创建一个 WebService 实例，实现服务端发布，客户端获取信息的功能。使用 idea 创建 springboot 项目，配置 WebService 和 web 依赖12341.编写 WebService 接口方法public interface HelloWebService &#123; String sayHello(String name);&#125; 123456789102.实现接口，作为 webservice 提供服务类 @WebServicepublic class HelloWebServiceImpl implements HelloWebService &#123; @Override public String sayHello(String name) &#123; String said = name + \",Hello~~\"; System.out.println(said); return said; &#125;&#125; 12345678910111213141516173.发布服务@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); /* 在服务器端运行 WebServicePublish 类中的 main 方法，控制台打印出发布 webservice 成功！ 在浏览器中输入我们在 WebServicePublish 类中定义的 url?wsdl (注意一定要加 wsdl ),浏览器显示一个 xml 文档 那么我们这个 WebService 就发布成功了。 */ //定义 webService 的发布地址，提供给外界使用接口的地址 String url = \"http://localhost:8081/WebService\"; Endpoint.publish(url,new HelloWebServiceImpl()); System.out.println(\"发布 webService 成功！\"); &#125;&#125; 14.浏览器输入 `http://localhost:8081/WebService?wsdl` 测试服务是否发布成功 Web Service 客户端实现访问http://localhost:8081/WebService?wsdl，将文档下载保存为 wsdl 格式 idea 解析 wsdl 文件反向生成代码用 idea 新建一个 java 项目，导入 wsdl 文件 wsdl 文件右键点击–&gt; WebServices –&gt; Generate Java Code From Wsdl –&gt;选择解析规范 JAX-WS(idea自带) 123456789101112编写客户端public class HelloClient &#123; public static void main(String[] args) &#123; //创建服务视图，视图是从 wsdl 文件的 service 标签的 name 属性获取 HelloWebServiceImplService helloWebServiceImplService = new HelloWebServiceImplService(); //获取服务实现类，实现类从 wsdl 文件的 portType 的 name 属性获取 HelloWebServiceImpl helloWebService = helloWebServiceImplService.getPort(HelloWebServiceImpl.class); //获取查询方法，从 portType的operation 标签获取 String str = helloWebService.sayHello(\"小明\"); System.out.println(str); &#125;&#125; 直接执行，控制台成功输出","categories":[{"name":"Web Service","slug":"Web-Service","permalink":"http://yoursite.com/categories/Web-Service/"}],"tags":[],"keywords":[{"name":"Web Service","slug":"Web-Service","permalink":"http://yoursite.com/categories/Web-Service/"}]},{"title":"Axure 入门使用","slug":"Axure","date":"2018-11-12T14:26:50.000Z","updated":"2018-12-27T09:17:43.679Z","comments":true,"path":"2018/11/12/Axure/","link":"","permalink":"http://yoursite.com/2018/11/12/Axure/","excerpt":"","text":"Axure RP 是一款专业的快速原型设计工具。Axure RP 是美国 Axure Software Solution 公司旗舰产品，是一个专业的快速原型设计工具，让负责定义需求和规格、设计功能和界面的专家能够快速创建应用软件或 Web 网站的线框图、流程图、原型和规格说明文档。作为专业的原型设计工具，它能快速、高效的创建原型，同时支持多人协作设计和版本控制管理。 下载Axure RP 是收费软件，只有30天免费试用，可以到下面官网下载。Axure官网下载：https://www.axure.com/download 百度云资源下载链接：https://pan.baidu.com/s/1dLmf5aptMGjYQYiyozgpHg提取码：t30y 安装双击 AxureRP-setup.exe 进入安装提示页面，按 “下一步” 一直到完成安装。 打开软件，点击 “Enter License” 将 注册码.txt 中的激活码输入进去，或者进入 帮助-&gt;管理授权 输入激活码。 汉化(汉化包中附有步骤)1.关闭 Axure RP 软件，将 汉化包.rar 文件解压, 得到 lang 文件夹。2.将解压后的 lang 文件夹添加到软件的安装目录中。 使用资源提供《Axure RP 8 实战手册》pdf，可以根据内容进行练习。 在线资源Axure 官方中文网Axure RP 8 实战手册","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Spring Boot:Whitelabel Error Page 错误解决","slug":"Spring-Boot-Whitelabel-Error-Page","date":"2018-11-11T16:00:00.000Z","updated":"2018-12-27T09:16:45.796Z","comments":true,"path":"2018/11/12/Spring-Boot-Whitelabel-Error-Page/","link":"","permalink":"http://yoursite.com/2018/11/12/Spring-Boot-Whitelabel-Error-Page/","excerpt":"","text":"使用 Spring Boot 构建一个简单的工程，访问报错，页面显示 Whitelabel Error Page 404，找了很久，路径没错，注解也没错，毫无头绪。最后只能求助于百度了，终于知道问题出在哪里了。原因：程序只加载启动类所在包及其子包下的内容。我不小心包启动类放在了 web 包下，导致 dao 其他包的代码加载不到。 解决方法：1.在 Application 类中加上@ComponentScan(basePackages = {&quot;com.example&quot;})多个之间用”,”分隔。2.将启动类放在正确位置。","categories":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}],"tags":[],"keywords":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/categories/spring-boot/"}]},{"title":"Markdown 入门","slug":"markdown","date":"2018-11-02T09:29:07.000Z","updated":"2018-12-27T09:14:48.308Z","comments":true,"path":"2018/11/02/markdown/","link":"","permalink":"http://yoursite.com/2018/11/02/markdown/","excerpt":"Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown 的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。","text":"Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown 的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。 标题以#表示，一个#最大，共六级 123456# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 一级标题二级标题三级标题四级标题五级标题六级标题 列表无序列表用 - + * 任何一种都可以12345678#### 无序列表 - 足球 + 篮球 * 乒乓球#### 有序列表 1. 足球 2. 篮球 3. 乒乓球 无序列表 足球 篮球 乒乓球 有序列表 足球 篮球 乒乓球 引用只需要在文本前加入 &gt; 这种尖括号（大于号）即可引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; 1234&gt; &amp;gt; &gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 &gt;这是引用的内容 这是引用的内容 这是引用的内容 图片与链接图片为：![]()链接为：[]()12![图片](https://mouapp.com.Mou_128.png) [百度](www.baidu.com) 链接：百度 粗体、斜体与删除线1234**粗体** *斜体* ***加粗并倾斜*** ~~删除线~~ 粗体粗体斜体加粗并倾斜删除线 表格12345| Tables | Are | Cool | | ------------- |:-------------:| -----:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码框 两个 ` 把代码包含(单行代码)三个 ` 报代码包含(多行代码) System.out.println(&quot;Hello MarkDown!&quot;)1System.out.println(\"Hello MarkDown!\") 字体、字号与颜色1234567&lt;font face=\"黑体\"&gt;我是黑体字&lt;/font&gt;&lt;font face=\"微软雅黑\"&gt;我是微软雅黑&lt;/font&gt;&lt;font face=\"STCAIYUN\"&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=5 face=\"黑体\"&gt;color=#0099ff size=72 face=\"黑体\"&lt;/font&gt;Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3。&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;&lt;font color=gray size=72&gt;color=gray&lt;/font&gt; 我是黑体字我是微软雅黑我是华文彩云color=#0099ff size=5 face=”黑体”color=#00ffffcolor=gray 居中&lt;center&gt;居中显示&lt;center&gt; 居中显示 分割线分割线的语法只需要三个 * 号1234-------*** **** 参考：[1]: https://www.jianshu.com/p/1e402922ee32/","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Hexo 入门","slug":"Hello-World","date":"2018-10-15T16:00:00.000Z","updated":"2018-12-27T02:49:45.835Z","comments":true,"path":"2018/10/16/Hello-World/","link":"","permalink":"http://yoursite.com/2018/10/16/Hello-World/","excerpt":"","text":"Hexo官网Hexo文档Hexo GitHub 快速开始新建文章12$ hexo new \"My New Post\"$ hexo n \"My New Post\" (简写) 更多信息: Writing 启动服务12$ hexo server$ hexo s (简写) 更多信息: Server 生成静态文件12$ hexo generate$ hexo g (简写) 更多信息: Generating 部署到远程站点12$ hexo deploy$ hexo d (简写) 更多信息: Deployment","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]}]}